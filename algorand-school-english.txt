Algorand School

2022


Cosimo Bassi
Solutions Architect at Algorand Inc.

cosimo.bassi@algorand.com

Open Source: github.com/cusma/algorand-school

Our journey today:

understanding Algorand Consensus and Algorand Networks, how to use Algorand Dev Tools, how to develop decentralized applications on the Algorand Virtual Machine

Agenda

Blockchain as an infrastructure
Analog properties for Digital things
Algorand Consensus
Algorand Sustainability
Algorand Decentralized Governance
Algorand Networks
Algorand Interoperability
Algorand Transactions
Algorand Accounts
Algorand Standard Assets
Algorand Virtual Machine
Algorand Smart Contracts on Layer-1
Smart Signatures & Smart Contracts
TEAL
PyTEAL & ABI & Beaker
dApp Example & Use Cases

4
BLOCKCHAIN AS INFRASTRUCTUREFor native digital value

Blockchain is a digital infrastructure for value
5
"The ability to create something which is not duplicable in the digital world has enormous value."

Eric Schmidt


The infrastructure trilemma
6
TRILEMMA
2
3
1
SECURITY (INT/EXT)
ACCESSIBILITY
EFFICIENCY
Public or private? Who has the control? Duty and responsibility? Aligned incentives?


The problem of native digital value
7
In the digital age
everything can be represented in bits 
as a string of 0 and 1
Strings of 0 and 1 are useful
because you can
duplicate them easily
Value is therefore difficult to represent in the digital age:
SCARCITY, AUTHENTICITY, UNICITY


How to build such infrastructure? Protocol is the answer
8
Just like TCP/IP is the foundational protocol for the modern Internet infrastructure, we will solve the problem through an protocol.

This is not just an information technology problem
9
DISTRIBUTED SYSTEMS
CRYPTOGRAPHY
GAME THEORY
PUBLIC
TAMPER-PROOF
TRANSPARENT
TRUSTLESS
LEDGER
Distributed systems and cryptography are elements of the communication infrastructure. We need a third element: game theory.

Who controls the system? Nobody‚Ä¶ everybody!
10
PAST
FUTURE
DISTRIBUTED SYSTEMS
No absolute power, no single point of failure.


Don‚Äôt trust, verify!
11
Nobody can break the rules‚Ä¶
and
‚Ä¶everybody can verify.
CRYPTOGRAPHY


Align incentives: collective self-protecting system
12
GAME THEORY
Equilibrium in which attacking the system is less convenient than protecting it.

Cost of the attack: make malicious behaviours expensive.


13
ANALOG PROPERTIES
FOR DIGITAL THINGS
Consensus as ‚Äúlaw of Physics‚Äù for digital world

Who owns what? Let‚Äôs write it down!
14
A blockchain is a public ledger of transactional data.
World's first writing ‚Äî cuneiform ‚Äî traces its beginnings back to an ancient system of accounting.
WHO

OWNS

WHAT
Writing systems: from prehistory to history of humankind.

More copies are better than one!
15
Distributed and replicated across a system of multiple nodes in a network.
All ‚Äúledger keepers‚Äù should work together, using the same set rules, to verify the transactions to add to each copy of the finalized ledger. 


16
Atoms can‚Äôt be copy & pasted and are obliged to follow the arrow of time!
Bits can be copy & pasted and are not obliged to follow the arrow of time!
Entropy, irreversibility and the arrow of time
In a distributed system is hard to ensure that the information follows a consequential time. Also, the arrow of time could bypassed reverting transactions. The ledger of information must respect a precise history and must not allow arbitrary creation, duplication or deletion of information. 

A chain of transactions organized in blocks
17
The ‚Äúblock‚Äù refers to a set of transactions that are proposed and verified by the other nodes and eventually added to the ledger (no copy & paste).
The ‚Äúchain‚Äù refers to the fact that each block of transactions contains proof (a cryptographic hash) of what was in the previous block (arrow of time).





Can transactions be reverted or modified ex-post? No! Dura lex, sed lex!


A distributed state machine
18
A machine
The evolution of the states of the system is determined‚Ä¶

SYSTEM STATE
S0

SYSTEM STATE
Sn

SYSTEM STATE
S1
BLOCK N
SMART CONTRACT
TRANSACTION
The evolution of the states of the system is determined‚Ä¶
‚Ä¶acting on atoms, through the inviolable laws of Physics!
‚Ä¶acting on bits, through what?
BLOCK 1
SMART CONTRACT
TRANSACTION
The more complex the state transition the more power I consume: adding 1 transaction per month is easy, executing thousands of smart contracts on the AVM is complicated.

The responsibility of correct information
19
Margaret Hamilton in 1969, standing next to listings of the software she and her MIT team produced for the Apollo project.
BLOCK PROPOSER
GENESIS BLOCK
BLOCK 1
BLOCK N
BLOCK N+1
How should we replace the role played by the law of Physics in evolving the state of a machine?

With a set of software rules, called Consensus Protocol that evolves the state of the system. 
Paleo-computing: no IDE, no syntax highlighting, handwritten code (value of conciseness).

The architecture of consensus
20
Temple of Concordia
Valley of Temples (Agrigento), 440-430 B.C.
How to choose the proposer for the next block for a public and permissionless blockchain?

How to ensure that there is no ambiguity in the choice of the next block?

How to ensure that the blockchain stays unique and has no forks?

How to ensure that consensus mechanism itself can evolve over time while the blockchain is an immutable ledger?
It is the largest and best-preserved Doric temple in Sicily[5] and one of the best-preserved Greek temples in general,[1] especially of the Doric order. Named after Concordia.
In ancient Roman religion, Concordia is the goddess who embodies agreement in society. Her Greek equivalent is usually regarded as Harmonia, with musical harmony a metaphor for an ideal of social concord.
This tells us a lot about the value of such a civilization!

Proof of Work consensus mechanism
21
Miners compete with each other to append the next block and earn a reward for the effort, fighting to win an expensive computational battle.
The more computational power, the higher the probability of being elected as block proposer.
PoW


Proof of Work limits
22
Huge electrical consumption

Concentration of governance in few mining farms

Soft-forking of the blockchain


Proof of Stake consensus mechanism
23
Network participants show their commitment and interest in keeping the ledger safe and secure proving the ownership of value stored on the ledger itself.

The higher the skin in the game the higher the probability of being elected as block proposer.


Proof of Stake limits
24
CRITICAL ISSUES
BONDED PROOF OF STAKE
Validators bind their stake, to show their commitment in validating and appending a new block. Misbehaviors are punished.
Participating in the consensus protocol makes users‚Äô stakes illiquid
Risk of economic barrier to entry
DELEGATED PROOF OF STAKE
Users delegate the validation of new blocks to a fixed committee, through weighted voting based on their stakes.
Known delegate nodes, therefore exposed to DDoS attacks
Centralization of governance
BPoS
DPoS
It‚Äôs like playing Battleship knowing the coordinates of adversary in advance.

Is the Blockchain Trilemma unsolvable?
25
TRILEMMA
2
3
1
SECURITY
SCALABILITY
DECENTRALIZATION


26
ALGORAND CONSENSUSPure Proof of Stake (PPoS)

Scalable		6000 TPS, billions of users
Fast			< 3.9 s per block
Secure		0 downtime for over 22M blocks
Low fees		0.001 ALGO per txn
No Soft Forks 	prob. < 10-18
Instant Transaction Finality
Carbon neutral
Minimal hardware node requirements
No delegation or binding of the stake
No minimum stake
Secure with respect DDoS
Network Partitioning resilience
Algorand PPoS Consensus
27
Silvio Micali  Algorand Founder
Professor MIT, Turing Award, G√∂del Prize
Digital Signatures, Probabilistic Encryption, Zero-Knowledge Proofs,
Verifiable Random Functions and other primitives of modern cryptography.

Flat fee is very powerful for business models: given a users base, an estimation of users activity (tx/day) a business team can foresee the costs and hedge the on-chain resources.

Tamper-proof, unique and verifiable dices
28





VRF
Dices are perfectly balanced and equiprobable, nobody could tamper their result!
Keep observing dice rolls by no means increases the chance of guessing the next result!
Each dice is uniquely signed by its owner, nobody can roll someone else dices!
Dices are publicly verifiable, everybody can read the results of a roll!


Who chose the next block?
29
VRF
VRF
VRF
VRF
WIN!
Each ALGO could be assimilated to a tamper-proof dice participating in a safe and secret cryptographic dice roll. More ALGOs more dices to roll.

For each new block, dice rolls are performed in a distributed, parallel and secret and manner, directly on online accounts‚Äô hardware (in microseconds).

The winner is revealed in a safe and verifiable way only after winning the dice roll, proposing the next block.


A glimpse on ‚Äúsimplified‚Äù VRF sortition
30
A secret key (SK) / public verification key (VK) pair is associated with each ALGO in the account
For each new round r of the consensus protocol a threshold L(r) is defined
Each ALGO in the account performs a VRF, using its own secret key (SK), to generate:
a pseudo-random number:		Y = VRFSK(seed)
the verifiable associated proof:	‚ç¥SK(seed)
If Y = VRFSK(seed) < L(r), that specific ALGO ‚Äúwins the lottery‚Äù and viraly propagates the proof of its victory ‚ç¥SK(seed) to other network‚Äôs nodes, through ‚Äúgossiping‚Äù mechanism
Others node can use the public verification key (VK) to verify, through ‚ç¥SK(seed), that the number Y was generated by that specific ALGO, owned by the winner of the lottery


Pure Proof of Stake, in short
31
Through the cryptographic lottery, an online account is elected with probability directly proportional to its stake: each ALGO corresponds to an attempt to win the lottery!




An account is elected to propose the next block
A committee is elected to filter and vote on the block proposals
A new committee is elected to reach a quorum and certify the block
The new block is appended to the blockchain
Each round of the consensus protocol appends a new block in the blockchain:


Ok, but‚Ä¶ how long does it take?
32


Less than 3.9 seconds!
33


Pure Proof of Stake security
34
Algorand‚Äôs decentralized Byzantine consensus protocol can tolerate an arbitrary number of malicious users as long as honest users hold a super majority of the total stake in the system.
The adversary does not know which users he should corrupt.
The adversary realizes which users are selected too late to benefit from attacking them. 
Each new set of users will be privately and individually elected.
During a network partition in Algorand, the adversary is never able to convince two honest users to accept two different blocks for the same round.
Algorand is able to recover shortly after network partition is resolved and guarantees that new blocks will be generated at the same speed as before the partition.


Pure Proof of Stake: the output pre-upgrade!
35
BLOCKS
> 23M with 0 downtime
BLOCKCHAIN SIZE
~ 1 TB
ADDRESSES
> 27M with ~ 2M monthly active addresses
AVG. BLOCK FINALIZATION
~ 4,4 sec per block (pre-upgrade)
TXNS WEEKLY VOLUME
~ 11M transactions (March 2022)
TPS WEEKLY PEAK
~ 1150 transactions per second
* up to August 2022
This is the output that such a complex machine has produced so far‚Ä¶ We still have to answer to the opening question: ‚Äúis this machine good at consuming input resources to produce the desired output for which it has been designed for?‚Äù

Algorand Layer-1 primitives
36

Algorand Standard Assets (ASA)

Atomic Transfers
(AT)

Algorand Virtual Machine (AVM)





Algorand State Proof (ASP)




TRUSTLESS
INTEROPERABLE
POST-QUANTUM SECURE





What does execution on Layer-1 mean?
37
B1
B2
...
Br
ASC1 CALL
ASC1 CALL
ASC1 CALL
TXN 1
ASC1 CALL
L-1 CONSENSUS COMMITTEE

4.5 sec
L-1 CONSENSUS COMMITTEE

4.5 sec
L-1 CONSENSUS COMMITTEE

4.5 sec
EXECUTION ON PPoS CONSENSUS LEVEL
up to 5000 txn/block
up to 5000 txn/block
AVM execution does not slow down the whole blocks production!
up to 5000 txn/block
up to 5000 txn/block
Each complex system is characterised by a ‚Äúnatural pulsation‚Äù. For electrical networks is the grid‚Äôs frequency, for automated assembly lines is the production tack-time. We, humans, are complex systems, our natural pulsations is the heartbeat. Block time is Algorand‚Äôs heartbeat!

What does execution on Layer-1 mean?
38
Smart Contracts are executed ‚Äúat consensus level‚Äù
Benefit from network's speed, security, and scalability
Fast trustless execution (~4.5 seconds per block)
Low cost execution (0.001 ALGO regardless SC‚Äôs complexity)
Instant Finality of Smart Contracts‚Äô effects
Native interoperability with Layer-1 primitives
Safe high level languages (PyTeal, Reach, Clarity)
Low energy consumption


39
ALGORAND SUSTAINABILITY‚ÄúPermission-less‚Äù is not ‚ÄúResponsibility-less‚Äù
Full paper: ‚ÄúProof of Stake Blockchain Efficiency Framework‚Äù

‚ÄúPermission-less‚Äù is not ‚ÄúResponsibility-less‚Äù
40
Algorand is a permission-less network üï∏, so no centralized authority can know or impose how node runners should power their nodes üíª.
As decentralized infrastructure, Algorand is responsible for its impact on Planet Earth üåè, although no centralized authority controls it.
Algorand should acts proactively (not hiding behind the ‚Äúpermission-less excuse‚Äù) and set blockchains‚Äô sustainability bar high üå±.


Proof of unsustainable Work
41
Proof of Work is a planetary wasteful computational battle, in which miners MUST burn energy to secure the blockchain.
Showing off personal commitment in the ecosystem through the consumption of computational and energetic resources is at the core of PoW consensus mechanism.

Our planet Earth can no longer afford unsustainable technologies.


42
A matter of orders of magnitude (PoW vs PPoS)
Eiffel Tower
Paper sheet thickness
2x Burj Khalifa
103
102
10-5
Full paper: ‚ÄúProof of Stake Blockchain Efficiency Framework‚Äù


43
You like to win easy!
What about others Proof of Stake?


When the going gets tough, the tough get going (PoS vs PPoS)
44
Blockchain sustainability must consider scalable end-user transactions (uTPS) finality (f), nodes hardware (N), and secure network decentralization (d).





Being sustainable while centralized, insecure or not scalable
is worthless!
DECENTRALIZED
SECURE
NETWORK
(running on Consensus Protocol)

(f, N, d)
INPUT
OUTPUT
POWER
(Pval)
END-USER
FINALIZED
TRANSACTIONS
(uTPS)


Reframing the question
45
Is Algorand blockchain efficient
at consuming energy 
to finalize end user useful transactions
in a secure, scalable and decentralized way?


Algorand solves blockchain trilemma sustainably
46
Algorand transactions are 100% available to end-users
(other PoS blockchains consume their own transactions for consensus)
Algorand transactions are 100% instantly final
(other PoS must consume the energy of several blocks to ensure transactions‚Äô finality)
Algorand transactions are secured by a very decentralized network
(some PoS blockchain have only few validators)
Algorand security is a feature of its own efficiency
(Algorand never experienced downtime since the genesis block)
Full paper: ‚ÄúProof of Stake Blockchain Efficiency Framework‚Äù


47
ALGORAND NETWORKSNodes, Indexer and APIs

Algorand Node configurations
48
Non-Relay Nodes
Participate in the PPoS consensus (if hosting participation keys)
Connect only to Relay Nodes 
Light Configuration: store just the lastest 1000 blocks (Fast Catch-Up)
Archival Configuration: store all the chain since the genesis block

Relay Nodes
Communication routing to a set of connected Non-Relay Nodes
Connect both with Non-Relay Nodes and Relay Nodes
Route blocks to all connected Non-Relay Nodes
Highly efficient communication paths, reducing communication hops


Example of Algorand Network topology
49
Node Metrics
Non-Relay Nodes: 	> 1600
Relay Nodes:		> 120


50
Access to Algorand Network
The Algorand blockchain is a distributed system of nodes each maintaining their local state based on validating the history of blocks and the transactions therein. Blockchain state integrity is maintained by the consensus protocol which is implemented within the Algod daemon (often referred to as the node software).

An application connects to the Algorand blockchain through an Algod client, requiring:

a valid Algod REST API endpoint IP address
an Algod token from an Algorand node connected to the network you plan to interact with

These two pieces of information can be provided by your local node or by a third party node aaS.


51
How to get an Algod Client?
There are three ways to get a REST API Algod endpoint IP address / access token, each with their respective pros and cons depending on development goals.


52
Algorand Networks


53
Algorand Node -  Writing on the blockchain
Install (Linux, MacOS, Windows)
Choose a network (MainNet, TestNet, BetaNet, PrivateNet)
Start & Sync with the network, Fast Catchup

genesis.json (mainnet)

{
  "alloc": [
    {
      "addr": "7377777777777777...77777777UFEJ2CI",
      "comment": "RewardsPool",
      "state": {
        "algo": 10000000000000,
        "onl": 2
      }
    },
    {
      "addr": "Y76M3MSY6DKBRHBL7C3...F2QWNPL226CA",
      "comment": "FeeSink",
      "state": {
        "algo": 1000000,
        "onl": 2
      }
    },
    ...
  ],
  "fees": "Y76M3MSY6DKBRHBL7C3NNDX...F2QWNPL226CA",
  "id": "v1.0",
  "network": "mainnet",
  "proto": "https://github.com/algorandfoundation/specs/tree/5615adc36bad610c7f165fa2967f4ecfa75125f0",
  "rwd": "737777777777777777777...77777777UFEJ2CI",
  "timestamp": 1560211200
}
Interacting with Algorand Nodes
CLI utilities: 		goal, kmd and algokey
REST API interface: 	algod V2, kmd, indexer
Algorand SDKs: 		JavaScript, Python, Java o Go


54
Algorand Indexer - Reading from the blockchain
The Indexer provides a REST API interface of API calls to query the Algorand blockchain. The Indexer REST APIs retrieves blockchain data from a PostgreSQL database, populated using the Indexer instance connected to an Archival Algorand node that reads blocks‚Äô data. As with the Nodes, the Indexer can be used as a third-party service.


55
How to interact with Algorand Node and Indexer


56
Algorand Community SDKs
Java
JavaScript
Python
Go
C#
Rust
Dart
PHP
Algorand SDKs
Swift


57
Algorand Developer Portal


58
Awesome Algorand


59
Algorand Wallets
Mobile Wallet + Wallet Connect
MyAlgo Wallet
AlgoSigner


60
Algorand Explorers


61
ALGORAND INTEROPERABILITYState Proofs and Post-Quantum Security
Credits to Noah Grossman for contens

Trustless interoperability
62
Algorand approach to interoperability:
cross-chain transactions should rely just on
Trust in departing consensus protocol
Trust in arrival consensus protocol
without centralized bridges or validator networks, to handle the assets.

Algorand State Proofs remove trusted centralized operators becoming the first trustless post-quantum secure L1 interoperability standard.


Post-Quantum Secure Algorand State Proofs
63
Post-Quantum secure and immutable proofs, attesting blockchain state, generated by Pure Proof of Stake consensus protocol.


64
ALGORAND TRANSACTIONS
Core element of blocks

Changing blockchain state
65
Transactions are the core element of blocks, which define the evolution of distributed ledger state. There are six transaction types in the Algorand Protocol:
Payment
Key Registration
Asset Configuration
Asset Freeze
Asset Transfer
Application Call

These six transaction types can be specified in particular ways that result in more granular perceived transaction types.


Signature, fees and round validity
66
In order to be approved, Algorand‚Äôs transactions must comply with:

Signatures: transactions must be correctly signed by its sender, either a Single Signature, a Multi Signature or a Smart Signature / Smart Contract
Fees: in Algorand transactions fees are a way to protect the network from DDoS. In Algorand Pure PoS fees are not meant to pay ‚Äúvalidation‚Äù (as it happens in PoW blockchains). In Algorand you can delegate fees.
Round validity: to handle transactions‚Äô idempotency, letting Non-Archival nodes participate in Algorand Consensus, transactions have an intrinsic validity of 1000 blocks (at most). 


Browse through a transaction
67
Transactions are characterized by two kind of fields (codec):

common (header)
specific (type)


Payment Transaction example
68
Here is a transaction that sends 5 ALGO from one account to another on MainNet.


69
ALGORAND ACCOUNTS
Transactions‚Äô Authorization

Signatures
70
SECRET KEY
32 bytes
PUBLIC KEY
32 bytes
Ed25519
GENERATOR
Algorand uses Ed25519 high-speed, high-security elliptic-curve signatures.
ALGORAND ADDRESS
58 characters
MNEMONIC PHRASE
25 words
RANDOM SEED
ADDRESS: the public key is transformed into an Algorand Address, by adding a 4-byte checksum to the end of the public key and then encoding it in base32.

MNEMONIC: the 25-word mnemonic is generated by converting the private key bytes into 11-bit integers and then mapping those integers to the bip-0039 English word list.


Algorand Accounts
71
Accounts are entities on the Algorand blockchain associated with specific on-chain local sate. An Algorand Address is the unique identifier for an Algorand Account.
All the potential keys pairs ‚Äúalready exists‚Äù mathematically, we just keep discovering them.


Transactions Authorization and Rekey-To
72
PUBLIC ADDRESS
MULTI SIGNATURE ACCOUNT
LOCAL STATE
SECRET KEY [1/N]
PUBLIC ADDRESS
STANDARD ACCOUNT
LOCAL STATE
SECRET KEY
CONTRACT ACCOUNT
SECRET KEY [k/N]
SECRET KEY [N/N]
Algorand Rekeying: powerful Layer-1 protocol feature which enables an Algorand account to maintain a static public address while dynamically rotating the authoritative private spending key(s). Any Account can Rekey either to a Standard Account, MultiSig Account or LogicSig Contract Account.
PUBLIC ADDRESS
SMART SIG
LOCAL STATE


Account State Minimum Balance
73


74
ASAAlgorand Standard Assets on Layer-1

ARC-3
Algorand Standard Asset Parameters Conventions for Fungible and Non-Fungible Tokens

75
Status: Final
Defines Fungible Tokens, Pure NFT, Fractional NFTs
Very comprehensive definition of NFT‚Äôs metadata (e.g. images, videos, audio tracks, etc.) and traits as JSON structure
Binding between the ASA and the JSON structure uploaded on external storage (e.g. IPFS, Arweave, etc.)
Circulating tokens: ~ 42,000
Generators: https://arc3.xyz/, https://app.algodesk.io/
Example: https://www.nftexplorer.app/asset/429087615



ARC-69
Community Algorand Standard Asset Parameters Conventions for Digital Media Tokens

76
Status: Living
Adopted both in art and games (https://algoseas.io/)
Simple and succinct definition of NFT‚Äôs metadata and traits as JSON structure. Allows tratits configuration after minting
Binding between the ASA and the JSON structure uploaded directly on-chain as transaction notefield
Circulating tokens: ~ 565,000 (most popular standard)
Generators: https://app.algodesk.io/
Example:  https://www.nftexplorer.app/asset/420625533



ARC-19
Templating of NFT ASA URLs for mutability

77
Status: Final
Has been adopted as building block of non-fungible-domain standard proposed by NFDomains
Makes use of ASA Reserve Address to update the NFT metadata binding over time.
Circulating tokens: ~ 26,000
Generators: https://app.nf.domains/
Example: https://app.nf.domains/name/john.algo



ARC-20 / ARC-18
Smart ASA / Royalty Enforcement Specification

78
Status: ARC-18 (Draft), ARC-20 (Draft)
Binds a native ASA with a Smart Contract creating a ‚ÄúSmart ASA‚Äù, useful whenever a decentralized transferability policy must be enforced on-chain (e.g. royalties, vesting, limited amount per day, etc.)
Allows ASA programmable full reconfigurability on the AVM (e.g. enforcing a rule to upgrade a trait of a NFT character in game, etc.) 
ARC-20 Reference Implementation
ARC-18 Reference Implementation (using Beaker)



79
ALGORAND VIRTUAL MACHINE (AVM)Programming on Algorand

What‚Äôs a Smart Contract ?
80
Smart Contracts are deterministic programs through which complex decentralized trustless applications can be executed on the AVM.
The Algorand Virtual Machine is a Turing-complete secure execution environment that runs on Algorand consensus layer.
What‚Äôs the AVM ?


Algorand Virtual Machine purpose: approving or rejecting transactions‚Äô effects on the blockchain according to Smart Contracts‚Äô logic.
What the AVM actually does?
81
AVM approves transactions‚Äô effects if and only if:
There is a single non-zero value on top of AVM‚Äôs stack;
AVM rejects transactions‚Äô effects if and only if:
There is a single zero value on top of AVM‚Äôs stack;
There are multiple values on the AVM‚Äôs stack;
There is no value on the AVM‚Äôs stack;


How the AVM works?
82
Suppose we want the AVM to check the following assertion:
1 + 2 = 3
[...]
[...]
[...]
[...]
[...]
STACK MACHINE


How the AVM works?
83
Suppose we want the AVM to check the following assertion:
1 + 2 = 3
1
[...]
[...]
[...]
[...]
STACK MACHINE
pushing first operand


How the AVM works?
84
Suppose we want the AVM to check the following assertion:
1 + 2 = 3
2
1
[...]
[...]
[...]
STACK MACHINE
pushing
second operand


How the AVM works?
85
Suppose we want the AVM to check the following assertion:
1 + 2 = 3
2
1
[...]
[...]
[...]
STACK MACHINE
applying
operator


How the AVM works?
86
Suppose we want the AVM to check the following assertion:
1 + 2 = 3
3
[...]
[...]
[...]
[...]
STACK MACHINE


How the AVM works?
87
Suppose we want the AVM to check the following assertion:
1 + 2 = 3
3
3
[...]
[...]
[...]
STACK MACHINE
pushing
last operand


How the AVM works?
88
Suppose we want the AVM to check the following assertion:
1 + 2 = 3
3
3
[...]
[...]
[...]
STACK MACHINE
applying
operator


How the AVM works?
89
Suppose we want the AVM to check the following assertion:
1 + 2 = 3
true
[...]
[...]
[...]
[...]
STACK MACHINE


AVM architecture
90
Sender
Receiver
Fee
FirstValid
LastValid
Amount
Lease
Note
TypeEnum
‚Ä¶ 
[0]:    Bytes
[i]:    Bytes
[255]:  Bytes
TRANSACTION
TRANSACTION ARGS
[0]:  UInt64 / Bytes
[i]:  UInt64 / Bytes
[63]: UInt64 / Bytes
APP GLOBAL K/V PAIRS
[0]:  UInt64 / Bytes
[i]:  UInt64 / Bytes
[15]: UInt64 / Bytes
APP LOCAL K/V PAIRS
[0]:  UInt64/ Bytes
[i]:  UInt64/ Bytes
[15]: UInt64/ Bytes
[0]:  Bytes
[i]:  Bytes
[3]:  Bytes
[0]:  UInt64
[i]:  UInt64
[7]:  UInt64
APP IDs ARRAY
ACCOUNT ARRAY
APP ARG ARRAY
txn TypeEnum
int 1
==
txn Receiver
addr AOC7...
==
&&
txn Fee
int 1000
<=
&&
arg 0
byte base64 "YmlhbmNvbmlnbGlv"
==
&&
txn Amount
int 42
==
txn Amount
int 77
==
||
&&
PROGRAM
[0]:    UInt64 / Bytes
[i]:    UInt64 / Bytes
[999]:  UInt64 / Bytes
STACK MACHINE
[0]:    UInt64 / Bytes
[i]:    UInt64 / Bytes
[255]:  UInt64 / Bytes
SCRATCH SPACE
[0]:  UInt64
[i]:  UInt64
[7]:  UInt64
ASSET ARRAY
Stateless properties
Stateful properties
Processing
Max Key + Value size: 128 bytes


NODE
COMPILERS
IDEs
How to program the AVM?
91
Algorand Virtual Machine (AVM)
TEAL
AVM Bytecode
PyTeal
TEAL
AVM Bytecode
Reach Lang
TEAL
AVM Bytecode
TEAL
AVM Bytecode
Languages...
...
...
...


AVM vs EVM
92
Algorand Virtual Machine
Ethereum Virtual Machine
TURING COMPLETENESS
YES
YES
EXECUTION SPEED
~ 4.5 sec
regardless dApp complexity
> 20 sec
depends on dApp complexity
ENERGY EFFICIENCY
~10-5 [kWh/txn]
all final
~102 [kWh/txn]
not all final
EXECUTION COSTS
Flat Fee for Smart Contract Calls and Inner Transactions
Depends on dApp complexity
INTEROPERABILITY
native interoperability
ASA, AT, MultiSig, RekeyTo...
user defined solutions / standards
EFFECTS FINALITY
instant
~ 6 blocks
MATHEMATICAL PRECISION
512 bits
256 bits
PROGRAMMABILITY
TEAL, PyTEAL, Reach, ...
Solidity, Viper, Reach, ...


What can be built on the AVM?
93
Escrow accounts
KYC processes
Financial instruments (Bonds, ETFs, etc.)
Loan payment
Voting applications
Auctions
Multiparty or Delegated fund management
Programmatic recurring fees / recurring debt
And more...


94
ASC1Algorand Smart Contracts on Layer-1

AVM Modes
95
ASC1
Mode 1:
SMART SIGNATURE
(Stateless)
Mode 2:
SMART CONTRACTS
(Stateful)


Mode 1:
SMART SIGNATURE
(Stateless)
Stateless ASC1
96
ASC1
Mode 2:
APPLICATION
(Stateful)
Contract
Account
Application
Smart Signatures are programs whose logic governs transactions‚Äô authorization.
Domain: transient properties
‚ÄúStateless ASC1 deal with assets‚Äô spending approvals‚Äù
Delegated
Signature


Stateful ASC1
97
ASC1
Mode 1:
LOGIC SIGNATURE
(Stateless)
Contract
Account
Application
Delegated
Signature
Smart Contracts are programs whose logic reads and writes blockchain‚Äôs state, creates and submits transactions.
Domain: persistent properties
‚ÄúStateful ASC1 deal with accounts‚Äô state changes‚Äù
Mode 2:
SMART CONTRACTS
(Stateful)


98
SMART SIGNATURESAuthorizing transactions through TEAL logic

Creating Smart Signature
99
txn TypeEnum
int 1
==
txn Receiver
addr AOC7...
==
&&
txn Fee
int 1000
<=
&&
arg 0
byte base64 "YmlhbmNvbmlnbGlv"
==
&&
txn Amount
int 42
==
txn Amount
int 77
==
||
&&
PROGRAM
NODE
SMART SIGNATURE
CONTRACT PUBLIC ADDRESS
Compiled TEAL Max Size: 1000 bytes
OpCode Max Budget: 20.000


Contract Account
100
CONTRACT ACCOUNT

ASC1 PUBLIC ADDRESS
LOCAL STATE
STANDARD / MULTISIG
ACCOUNT
TRANSACTION
SMART SIGNATURE
STANDARD / MULTISIG
ACCOUNT
funds...
appends...
binding


Delegated Signature
101
STANDARD / MULTISIG
ACCOUNT
SMART SIGNATURE
DELEGATED SIGNATURE
TRANSACTION
STANDARD / MULTISIG
ACCOUNT
STANDARD / MULTISIG
ACCOUNT
signs...
appends...
PUBLIC ADDRESS
SECRET KEY
binding


102
SMART CONTRACTSDecentralized Applications on Algorand

Deploying Applications on chain
103
txn TypeEnum
int 1
==
txn Receiver
addr AOC7...
==
&&
txn Fee
int 1000
<=
&&
arg 0
byte base64 "YmlhbmNvbmlnbGlv"
==
&&
txn Amount
int 42
==
txn Amount
int 77
==
||
&&
submits...
PROGRAM
NODE
APPLICATION
CREATE
TRANSACTION
B1
B2
B3
...
Br
BLOCKCHAIN
APPLICATION ID
Compiled TEAL Max Size: 2048 bytes (+3 Extra Pages)
OpCode Max Budget: 700 (x16 Atomic Calls)


Interacting with Applications
104
APPLICATION CALL
TRANSACTION
APPLICATION
(PROGRAM ON-CHAIN)
APP USER
ACCOUNT 1
LOCAL STATE

KYC:    PASSED
APP USER
ACCOUNT 2
LOCAL STATE

KYC:    PENDING
APP USER
ACCOUNT...
LOCAL STATE

KYC:    REJECTED
GLOBAL STATE

INTEREST RATE:    1%
INNER
TRANSACTION
Apps
Arguments
Assets
Accounts
LOG VALUE


105
TEALAVM assembly-like language

Smart Signature Example
106
Suppose we want to develop a Smart Signature that approves a transaction if and only if:

is ‚ÄúPayment‚Äù type transaction;
the receiver is a specific ‚ÄúADDR‚Äù;
fees are less or equal to ‚Äú1000 microALGO‚Äù;
first argument is equal to ‚Äúbianconiglio‚Äù;
amount is  equal to ‚Äú42 ALGO‚Äù;
or amount is equal to ‚Äú77 ALGO‚Äù;

Where do we start?


Smart Signature as ‚ÄúTransaction Observer‚Äù
107
Smart Signatures can be defined as a ‚Äútransactions‚Äô observers‚Äù: programs that meticulously check all fields in the transaction (or in a group of transactions) that intend to ‚Äúapprove‚Äù or ‚Äúreject‚Äù based on TEAL logic.

To translate those 6 semantically defined example‚Äôs conditions into TEAL we need to check which transaction fields are going to be controlled by Smart Signature‚Äôs logic.



Let's start with the translation...


Translating conditions into TEAL‚Ä¶
108
is ‚ÄúPayment‚Äù type transaction;
txn TypeEnum
int 1
==
1


109
the receiver is a specific ‚ÄúADDR‚Äù;
txn Receiver
addr AOC7...
==
2
Translating conditions into TEAL‚Ä¶


110
fees are less or equal to ‚Äú1000 microALGO‚Äù;
txn Fee
int 1000
<=
3
Translating conditions into TEAL‚Ä¶


111
first argument is equal to ‚Äúbianconiglio‚Äù;
arg 0
byte base64 "YmlhbmNvbmlnbGlv"
==
4
Translating conditions into TEAL‚Ä¶


112
amount is  equal to ‚Äú42 ALGO‚Äù;
txn Amount
int 42000000
==
5
Translating conditions into TEAL‚Ä¶


113
amount is  equal to ‚Äú77 ALGO‚Äù;
txn Amount
int 77000000
==
6
Translating conditions into TEAL‚Ä¶


114
Logic connectors‚Ä¶
txn TypeEnum
int 1
==
txn Receiver
addr AOC7...
==
&&
txn Fee
int 1000
<=
arg 0
byte base64 "YmlhbmNvbmlnbGlv"
==
&&
&&
txn Amount
int 42000000
==
txn Amount
int 77000000
==
||
&&
[...]
[...]
STACK
[...]
[...]
[...]
1
2
3
4
5
6


115
Logic connectors‚Ä¶
txn TypeEnum
int 1
==
txn Receiver
addr AOC7...
==
&&
txn Fee
int 1000
<=
arg 0
byte base64 "YmlhbmNvbmlnbGlv"
==
&&
&&
txn Amount
int 42000000
==
txn Amount
int 77000000
==
||
&&
[...]
[...]
STACK
[...]
[...]
[...]
1
2
3
4
5
6
This is probably the most complex phase in TEAL programming, because you need to keep in mind the state of the stack.

This phase is drastically simplified with the use of PyTEAL, Python binding for TEAL, which automatically performs this concatenation, saving us the effort of thinking about the state of the stack.


116
Execution‚Ä¶
txn TypeEnum
int 1
==
txn Receiver
addr AOC7...
==
&&
txn Fee
int 1000
<=
arg 0
byte base64 "YmlhbmNvbmlnbGlv"
==
&&
&&
txn Amount
int 42000000
==
txn Amount
int 77000000
==
||
&&
1
STACK
[...]
[...]
[...]
[...]


117
Execution‚Ä¶
txn TypeEnum
int 1
==
txn Receiver
addr AOC7...
==
&&
txn Fee
int 1000
<=
arg 0
byte base64 "YmlhbmNvbmlnbGlv"
==
&&
&&
txn Amount
int 42000000
==
txn Amount
int 77000000
==
||
&&
1
1
STACK
[...]
[...]
[...]


118
Execution‚Ä¶
txn TypeEnum
int 1
==
txn Receiver
addr AOC7...
==
&&
txn Fee
int 1000
<=
arg 0
byte base64 "YmlhbmNvbmlnbGlv"
==
&&
&&
txn Amount
int 42000000
==
txn Amount
int 77000000
==
||
&&
1
1
[...]
[...]
[...]
STACK


119
Execution‚Ä¶
txn TypeEnum
int 1
==
txn Receiver
addr AOC7...
==
&&
txn Fee
int 1000
<=
arg 0
byte base64 "YmlhbmNvbmlnbGlv"
==
&&
&&
txn Amount
int 42000000
==
txn Amount
int 77000000
==
||
&&
1
STACK
[...]
[...]
[...]
[...]


120
Execution‚Ä¶
txn TypeEnum
int 1
==
txn Receiver
addr AOC7...
==
&&
txn Fee
int 1000
<=
arg 0
byte base64 "YmlhbmNvbmlnbGlv"
==
&&
&&
txn Amount
int 42000000
==
txn Amount
int 77000000
==
||
&&
[...]
[...]
STACK
1
[...]
AOC7...


121
Execution‚Ä¶
txn TypeEnum
int 1
==
txn Receiver
addr AOC7...
==
&&
txn Fee
int 1000
<=
arg 0
byte base64 "YmlhbmNvbmlnbGlv"
==
&&
&&
txn Amount
int 42000000
==
txn Amount
int 77000000
==
||
&&
[...]
[...]
STACK
1
AOC7...
AOC7...


122
Execution‚Ä¶
txn TypeEnum
int 1
==
txn Receiver
addr AOC7...
==
&&
txn Fee
int 1000
<=
arg 0
byte base64 "YmlhbmNvbmlnbGlv"
==
&&
&&
txn Amount
int 42000000
==
txn Amount
int 77000000
==
||
&&
[...]
[...]
1
AOC7...
AOC7...
STACK


123
Execution‚Ä¶
txn TypeEnum
int 1
==
txn Receiver
addr AOC7...
==
&&
txn Fee
int 1000
<=
arg 0
byte base64 "YmlhbmNvbmlnbGlv"
==
&&
&&
txn Amount
int 42000000
==
txn Amount
int 77000000
==
||
&&
1
STACK
1
[...]
[...]
[...]


124
Execution‚Ä¶
txn TypeEnum
int 1
==
txn Receiver
addr AOC7...
==
&&
txn Fee
int 1000
<=
arg 0
byte base64 "YmlhbmNvbmlnbGlv"
==
&&
&&
txn Amount
int 42000000
==
txn Amount
int 77000000
==
||
&&
1
STACK
1
[...]
[...]
[...]


125
Execution‚Ä¶
txn TypeEnum
int 1
==
txn Receiver
addr AOC7...
==
&&
txn Fee
int 1000
<=
arg 0
byte base64 "YmlhbmNvbmlnbGlv"
==
&&
&&
txn Amount
int 42000000
==
txn Amount
int 77000000
==
||
&&
1
STACK
[...]
[...]
[...]
[...]


126
Execution‚Ä¶
txn TypeEnum
int 1
==
txn Receiver
addr AOC7...
==
&&
txn Fee
int 1000
<=
arg 0
byte base64 "YmlhbmNvbmlnbGlv"
==
&&
&&
txn Amount
int 42000000
==
txn Amount
int 77000000
==
||
&&
[...]
[...]
STACK
1
[...]
1000


127
Execution‚Ä¶
txn TypeEnum
int 1
==
txn Receiver
addr AOC7...
==
&&
txn Fee
int 1000
<=
arg 0
byte base64 "YmlhbmNvbmlnbGlv"
==
&&
&&
txn Amount
int 42000000
==
txn Amount
int 77000000
==
||
&&
[...]
[...]
STACK
1
1000
1000


128
Execution‚Ä¶
txn TypeEnum
int 1
==
txn Receiver
addr AOC7...
==
&&
txn Fee
int 1000
<=
arg 0
byte base64 "YmlhbmNvbmlnbGlv"
==
&&
&&
txn Amount
int 42000000
==
txn Amount
int 77000000
==
||
&&
[...]
[...]
STACK
1
1000
1000


129
Execution‚Ä¶
txn TypeEnum
int 1
==
txn Receiver
addr AOC7...
==
&&
txn Fee
int 1000
<=
arg 0
byte base64 "YmlhbmNvbmlnbGlv"
==
&&
&&
txn Amount
int 42000000
==
txn Amount
int 77000000
==
||
&&
1
STACK
1
[...]
[...]
[...]


130
Execution‚Ä¶
txn TypeEnum
int 1
==
txn Receiver
addr AOC7...
==
&&
txn Fee
int 1000
<=
arg 0
byte base64 "YmlhbmNvbmlnbGlv"
==
&&
&&
txn Amount
int 42000000
==
txn Amount
int 77000000
==
||
&&
[...]
[...]
STACK
1
1
bianconiglio


131
Execution‚Ä¶
txn TypeEnum
int 1
==
txn Receiver
addr AOC7...
==
&&
txn Fee
int 1000
<=
arg 0
byte base64 "YmlhbmNvbmlnbGlv"
==
&&
&&
txn Amount
int 42000000
==
txn Amount
int 77000000
==
||
&&
1
[...]
STACK
1
bianconiglio
bianconiglio


132
Execution‚Ä¶
txn TypeEnum
int 1
==
txn Receiver
addr AOC7...
==
&&
txn Fee
int 1000
<=
arg 0
byte base64 "YmlhbmNvbmlnbGlv"
==
&&
&&
txn Amount
int 42000000
==
txn Amount
int 77000000
==
||
&&
1
[...]
STACK
1
bianconiglio
bianconiglio


133
Execution‚Ä¶
txn TypeEnum
int 1
==
txn Receiver
addr AOC7...
==
&&
txn Fee
int 1000
<=
arg 0
byte base64 "YmlhbmNvbmlnbGlv"
==
&&
&&
txn Amount
int 42000000
==
txn Amount
int 77000000
==
||
&&
1
STACK
1
[...]
[...]
1


134
Execution‚Ä¶
txn TypeEnum
int 1
==
txn Receiver
addr AOC7...
==
&&
txn Fee
int 1000
<=
arg 0
byte base64 "YmlhbmNvbmlnbGlv"
==
&&
&&
txn Amount
int 42000000
==
txn Amount
int 77000000
==
||
&&
1
STACK
1
[...]
[...]
1


135
Execution‚Ä¶
txn TypeEnum
int 1
==
txn Receiver
addr AOC7...
==
&&
txn Fee
int 1000
<=
arg 0
byte base64 "YmlhbmNvbmlnbGlv"
==
&&
&&
txn Amount
int 42000000
==
txn Amount
int 77000000
==
||
&&
1
STACK
1
[...]
[...]
[...]


136
Execution‚Ä¶
txn TypeEnum
int 1
==
txn Receiver
addr AOC7...
==
&&
txn Fee
int 1000
<=
arg 0
byte base64 "YmlhbmNvbmlnbGlv"
==
&&
&&
txn Amount
int 42000000
==
txn Amount
int 77000000
==
||
&&
1
STACK
1
[...]
[...]
[...]


137
Execution‚Ä¶
txn TypeEnum
int 1
==
txn Receiver
addr AOC7...
==
&&
txn Fee
int 1000
<=
arg 0
byte base64 "YmlhbmNvbmlnbGlv"
==
&&
&&
txn Amount
int 42000000
==
txn Amount
int 77000000
==
||
&&
1
STACK
[...]
[...]
[...]
[...]


138
Execution‚Ä¶
txn TypeEnum
int 1
==
txn Receiver
addr AOC7...
==
&&
txn Fee
int 1000
<=
arg 0
byte base64 "YmlhbmNvbmlnbGlv"
==
&&
&&
txn Amount
int 42000000
==
txn Amount
int 77000000
==
||
&&
42000000
STACK
1
[...]
[...]
[...]


139
Execution‚Ä¶
txn TypeEnum
int 1
==
txn Receiver
addr AOC7...
==
&&
txn Fee
int 1000
<=
arg 0
byte base64 "YmlhbmNvbmlnbGlv"
==
&&
&&
txn Amount
int 42000000
==
txn Amount
int 77000000
==
||
&&
42000000
42000000
STACK
[...]
[...]
1


140
Execution‚Ä¶
txn TypeEnum
int 1
==
txn Receiver
addr AOC7...
==
&&
txn Fee
int 1000
<=
arg 0
byte base64 "YmlhbmNvbmlnbGlv"
==
&&
&&
txn Amount
int 42000000
==
txn Amount
int 77000000
==
||
&&
42000000
42000000
[...]
[...]
1
STACK


141
Execution‚Ä¶
txn TypeEnum
int 1
==
txn Receiver
addr AOC7...
==
&&
txn Fee
int 1000
<=
arg 0
byte base64 "YmlhbmNvbmlnbGlv"
==
&&
&&
txn Amount
int 42000000
==
txn Amount
int 77000000
==
||
&&
1
STACK
1
[...]
[...]
[...]


142
Execution‚Ä¶
txn TypeEnum
int 1
==
txn Receiver
addr AOC7...
==
&&
txn Fee
int 1000
<=
arg 0
byte base64 "YmlhbmNvbmlnbGlv"
==
&&
&&
txn Amount
int 42000000
==
txn Amount
int 77000000
==
||
&&
42000000
STACK
1
[...]
1
[...]


143
Execution‚Ä¶
txn TypeEnum
int 1
==
txn Receiver
addr AOC7...
==
&&
txn Fee
int 1000
<=
arg 0
byte base64 "YmlhbmNvbmlnbGlv"
==
&&
&&
txn Amount
int 42000000
==
txn Amount
int 77000000
==
||
&&
42000000
77000000
STACK
1
[...]
1


144
Execution‚Ä¶
[...]
1
1
42000000
77000000
txn TypeEnum
int 1
==
txn Receiver
addr AOC7...
==
&&
txn Fee
int 1000
<=
arg 0
byte base64 "YmlhbmNvbmlnbGlv"
==
&&
&&
txn Amount
int 42000000
==
txn Amount
int 77000000
==
||
&&
STACK


145
Execution‚Ä¶
0
txn TypeEnum
int 1
==
txn Receiver
addr AOC7...
==
&&
txn Fee
int 1000
<=
arg 0
byte base64 "YmlhbmNvbmlnbGlv"
==
&&
&&
txn Amount
int 42000000
==
txn Amount
int 77000000
==
||
&&
STACK
1
[...]
[...]
1


146
Execution‚Ä¶
0
txn TypeEnum
int 1
==
txn Receiver
addr AOC7...
==
&&
txn Fee
int 1000
<=
arg 0
byte base64 "YmlhbmNvbmlnbGlv"
==
&&
&&
txn Amount
int 42000000
==
txn Amount
int 77000000
==
||
&&
STACK
1
[...]
[...]
1


147
Execution‚Ä¶
1
txn TypeEnum
int 1
==
txn Receiver
addr AOC7...
==
&&
txn Fee
int 1000
<=
arg 0
byte base64 "YmlhbmNvbmlnbGlv"
==
&&
&&
txn Amount
int 42000000
==
txn Amount
int 77000000
==
||
&&
STACK
1
[...]
[...]
[...]


148
Execution‚Ä¶
1
txn TypeEnum
int 1
==
txn Receiver
addr AOC7...
==
&&
txn Fee
int 1000
<=
arg 0
byte base64 "YmlhbmNvbmlnbGlv"
==
&&
&&
txn Amount
int 42000000
==
txn Amount
int 77000000
==
||
&&
STACK
1
[...]
[...]
[...]


149
Execution‚Ä¶
1
txn TypeEnum
int 1
==
txn Receiver
addr AOC7...
==
&&
txn Fee
int 1000
<=
arg 0
byte base64 "YmlhbmNvbmlnbGlv"
==
&&
&&
txn Amount
int 42000000
==
txn Amount
int 77000000
==
||
&&
STACK
[...]
[...]
[...]
[...]


150
Conclusion‚Ä¶
1
txn TypeEnum
int 1
==
txn Receiver
addr AOC7...
==
&&
txn Fee
int 1000
<=
arg 0
byte base64 "YmlhbmNvbmlnbGlv"
==
&&
&&
txn Amount
int 42000000
==
txn Amount
int 77000000
==
||
&&
STACK
[...]
[...]
[...]
[...]
True


151
PyTEALWriting Smart Contracts with Python
Credits to Jason Paulos for the PyTEAL presentation

What‚Äôs PyTEAL?
152
PyTEAL is a Python language binding for Algorand Virtual Machine.
PyTEAL allows Smart Contracts and Smart Signatures to be written in Python and then compiled to TEAL.


153
It‚Äôs easier with PyTEAL!
TEAL Source Code
txn Receiver
addr AOC7...
==
txn Amount
int 1000
<=
&&
COMPILE...
AVM bytecode
PyTEAL Source Code
And(
Txn.Receiver == Addr(AOC7...),
    	Txn.Amount <= Int(1000),
)

TEAL Source Code
txn Receiver
addr AOC7...
==
txn Amount
int 1000
<=
&&
COMPILE...
COMPILE...
AVM bytecode


154
Smart Signature written in PyTEAL


PyTEAL Basics - Intro
155
PyTEAL expressions represent an abstract syntax tree (AST)
You‚Äôre writing Python code that produces TEAL code.
from pyteal import *

program = ...
teal_source = compileTeal(program, mode=Mode.Application, version=5)


PyTEAL Basics - Types (1/2)
156
Two basic types:
uint64
byte strings
i = Int(5)
x = Bytes("content")
y = Bytes(b"\x01\x02\x03")
z = Bytes("base16", "05")


PyTEAL Basics - Types (2/2)
157
Conversion between types
Itob - integer to bytes (8-byte big endian)
Btoi - bytes to integer
Itob(i) # produces the byte string 0x0000000000000005
Btoi(z) # produces the integer 5


PyTEAL Basics - Math operators
158
Python math operators
i = Int(10)
j = i * Int(2) + Int(1)
k = And(Int(1), Or(Int(1), Int(0)))


PyTEAL Basics - Byte string manipulation
159
Byte string manipulation
x = Bytes("content")
y = Concat(Bytes("example "), x) # "example content"
z = Substring(y, Int(2), Len(y)) # "ample content"


PyTEAL Basics - Crypto utilities
160
Built-in crypto utilities
h_sha256 = Sha256(z)
h_sha512_256 = Sha512_256(z)
h_keccak = Keccak256(z)


PyTEAL Basics - Fields (1/3)
161
Fields from the current transaction
Txn.sender()
Txn.accounts.length()
Txn.application_args.length()
Txn.accounts[1]
Txn.application_args[0]
Txn.group_index()


PyTEAL Basics - Fields (2/3)
162
Fields from transactions in the current atomic group
Gtxn[0].sender()
Gtxn[Txn.group_index() - Int(1)].sender()
Gtxn[Txn.group_index() - Int(1)].accounts[2]


PyTEAL Basics - Fields (3/3)
163
Fields from execution context
Global.group_size()
Global.round() # current round number
Global.latest_timestamp() # UNIX timestamp of last round


PyTEAL Basics - Logs
164
Log publicly viewable messages to the chain
	Log(Bytes("message"))


PyTEAL Basics - State (1/2)
165
Global - one instance per application
App.globalPut(Bytes("status"), Bytes("active")) # write to global key "status"

status = App.globalGet(Bytes("status")) # read global key "status"

App.globalDel(Bytes("status")) # delete global key "status"


PyTEAL Basics - State (2/2)
166
Local - one instance per opted-in account per application
App.localPut(Txn.sender(), Bytes("level"), Int(1)) # write to sender's local key "level"
App.localPut(Txn.accounts[1], Bytes("level"), Int(2))  # write to other account's local key "level"

sender_level = App.localGet(Txn.sender(), Bytes("level"))  # read from sender's local key "level"

App.localDel(Txn.sender(), Bytes("level"))  # delete sender's local key "level"


PyTEAL Basics - Control Flow (1/5)
167
Approve the transaction and immediately exit
Approve()
Reject the transaction and immediately exit
Reject()


PyTEAL Basics - Control Flow (2/5)
168
Multiple expressions can be joined into a sequence
program = Seq(
   App.globalPut(Bytes("count"), App.globalGet(Bytes("count")) + Int(1)),
   Approve()
)


PyTEAL Basics - Control Flow (3/5)
169
Basic conditions can be expressed with If, Then, Else, ElseIf
program = Seq(
   If(App.globalGet(Bytes("count")) == Int(100))
   .Then(
       App.globalPut(Bytes("100th caller"), Txn.sender())
   )
   .Else(
       App.globalPut(Bytes("not 100th caller"), Txn.sender())
   ),
   App.globalPut(Bytes("count"), App.globalGet(Bytes("count")) + Int(1)),
   Approve(),
)


PyTEAL Basics - Control Flow (4/5)
170
Larger conditions can be expressed with Cond
program = Cond(
   [Txn.application_id() == Int(0), on_create],
   [Txn.on_completion() == OnComplete.UpdateApplication, on_update],
   [Txn.on_completion() == OnComplete.DeleteApplication, on_delete],
   [Txn.on_completion() == OnComplete.OptIn, on_opt_in],
   [Txn.on_completion() == OnComplete.CloseOut, on_close_out],
   [Txn.on_completion() == OnComplete.NoOp, on_noop],
   # error if no conditions are met
)


PyTEAL Basics - Control Flow (5/5)
171
Loops can be expressed with For and While
i = ScratchVar(TealType.uint64)

on_create = Seq(
   For(i.store(Int(0)), i.load() < Int(16), i.store(i.load() + Int(1)))
   .Do(
       App.globalPut(Concat(Bytes("index"), Itob(i.load())), Int(1))
   ),
   Approve(),
)


PyTEAL Basics - Subroutines (1/2)
172
Sections of code can be put into subroutines (Python decorators)
@Subroutine(TealType.uint64)
def isEven(i):
   return i % Int(2) == Int(0)

App.globalPut(Bytes("value_is_even"), isEven(Int(10)))


PyTEAL Basics - Subroutines (2/2)
173
Recursion is allowed
@Subroutine(TealType.uint64)
def recursiveIsEven(i):
   return (
       If(i == Int(0))
       .Then(Int(1))
       .ElseIf(i == Int(1))
       .Then(Int(0))
       .Else(recursiveIsEven(i - Int(2)))
   )


PyTEAL Basics - Inner Transactions (1/3)
174
Every application has control of an account
Global.current_application_address()


PyTEAL Basics - Inner Transactions (2/3)
175
Applications can send transactions from this account
Seq(
   InnerTxnBuilder.Begin(),
   InnerTxnBuilder.SetFields(
       {
           TxnField.type_enum: TxnType.Payment,
           TxnField.receiver: Txn.sender(),
           TxnField.amount: Int(1_000_000),
       }
   ),
   InnerTxnBuilder.Submit() # send 1 Algo from the app account to the transaction sender
)


PyTEAL Basics - Inner Transactions (3/3)
176
appAddr = Global.current_application_address()
Seq(
   InnerTxnBuilder.Begin(),
   InnerTxnBuilder.SetFields(
       {
           TxnField.type_enum: TxnType.AssetConfig,
           TxnField.config_asset_name: Bytes("PyTEAL Coin"),
           TxnField.config_asset_unit_name: Bytes("PyTEAL"),
           TxnField.config_asset_url: Bytes("https://pyteal.readthedocs.io/"),
           TxnField.config_asset_decimals: Int(6),
           TxnField.config_asset_total: Int(800_000_000),
           TxnField.config_asset_manager: appAddr,
       }
   ),
   InnerTxnBuilder.Submit(), # create a PyTEAL Coin asset
   App.globalPut(Bytes("PyTealCoinId"), InnerTxn.created_asset_id()) # remember the asset ID
)


Smart Contract ABI
177
The ABI (Application Binary Interface) defines the encoding/decoding of data types and a standard for exposing and invoking methods in a Smart Contract. The specification is defined in ARC-4.
At a high level, the ABI allows contracts to define an API so clients know exactly what the Smart Contract is expecting to be passed (like a ‚ÄúSmart Contract Swagger‚Äù).
PyTeal natively supports the ABI standard: it handles methods signatures and ABI JSON auto-generation.


Beaker: Smart Contract development framework
178
Beaker improves the PyTeal Smart Contract development experience, making it simpler, cleaner and faster both to write and debug:
Provides a standard way to organize code by using a Application class with @external (methods) and @internal (subroutine) decorators, with utilities for call authorization;
Provides an ApplicationClient to deal with common needs like creating/opting-in to/calling methods;
Provides a standard way to declare Global and Local sate, with typed values as class variables and utilities as: default values, static variables, variable initialization, etc.;
Improves the pc=xxx error message using the SourceMap endpoint during compilation and mapping the pc back to the source TEAL with a LogicException.


A pythonic Algorand stack
179
Algorand Python SDK
PyTEAL & Beaker
PyTest for Smart Contracts unit-tests and e2e-tests
TEAL Debugger
Algorand Sandbox Docker in dev mode
PyCharm IDE & AlgoDEA plug-in


‚ÄúZero to Hero PyTEAL‚Äù crash course
180
Join and learn in 12 lessons!


181
DAPP EXAMPLE & USE CASESExample: zero coupon bond

Zero coupon bond
182
Bondholder purchase a bond (only if KYC has been verified)
Bond application checks for bond‚Äôs maturity
Bond Issuer re-pays the Bondholder at given rate


BONDHOLDER
ACCOUNT
BOND ESCROW
CONTRACT ACCOUNT
Zero coupon bond
183
Bondholder purchase a bond (only if KYC has been passed)
BOND
APPLICATION
ATOMIC TRANSACTION

BOND
APPLICATION CALL
CBDC TRANSFER TRANSACTION
BOND TRANSFER TRANSACTION
CBDC
BOND
KYC
APPLICATION
LOCAL STATE

KYC:    PASSED


reads


BONDHOLDER
ACCOUNT
Zero coupon bond
184
Bond application checks for bond‚Äôs maturity
BOND ESCROW
CONTRACT ACCOUNT
LOCAL STATE

KYC:    PASSED

BOND MATURE:   NO
BOND
reads
CBDC
BOND
APPLICATION


Zero coupon bond
185
Bond Issuer re-pays the Bondholder at given rate
ATOMIC TRANSACTION

BOND ESCROW
CONTRACT ACCOUNT
BONDHOLDER
ACCOUNT
BOND APPLICATION CALL
BOND TRANSFER TRANSACTION
CBDC TRANSFER TRANSACTION
BOND
APPLICATION
BOND ISSUER
ACCOUNT
CBDC
GLOBAL STATE

INTEREST RATE:    1%
LOCAL STATE

KYC:    PASSED

BOND MATURE:   YES
BOND


Thanks to the contributors!

Jason Paulos
Pietro Grassano
