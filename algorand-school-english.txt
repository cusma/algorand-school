Algorand School

2022







Open Source: github.com/cusma/algorand-school

Our journey today:

understanding Algorand Consensus and Algorand Networks, how to use Algorand Dev Tools, how to develop decentralized applications on the Algorand Virtual Machine

Agenda

Blockchain as an infrastructure
Analog properties for Digital things
Algorand Consensus
Algorand Sustainability
Algorand Networks
Algorand Interoperability
Algorand Transactions
Algorand Accounts
Algorand Standard Assets & ARCs
Algorand Virtual Machine
Algorand Smart Contracts on Layer-1
Smart Signatures & Smart Contracts
TEAL
PyTEAL
Algorand ABI
Beaker

4
Introduction to Algorand
An efficient public infrastructure for digital value






Cosimo Bassi
Solutions Architect at Algorand

cosimo.bassi@algorand.com


Blockchain is a digital infrastructure for value
6
"The ability to create something which is not duplicable in the digital world has enormous value."

Eric Schmidt


The infrastructure trilemma
7
TRILEMMA
2
3
1
SECURITY (INT/EXT)
ACCESSIBILITY
EFFICIENCY
Public or private? Who has the control? Duty and responsibility? Aligned incentives?


The problem of native digital value
8
In the digital age
everything can be represented in bits 
as a string of 0 and 1
Strings of 0 and 1 are useful
because you can
duplicate them easily
Value is therefore difficult to represent in the digital age:
SCARCITY, AUTHENTICITY, UNICITY


How to build such infrastructure? Protocol is the answer
9
Just like TCP/IP is the foundational protocol for the modern Internet infrastructure, we will solve the problem through an protocol.

This is not just an information technology problem
10
DISTRIBUTED SYSTEMS
CRYPTOGRAPHY
GAME THEORY
PUBLIC
TAMPER-PROOF
TRANSPARENT
TRUSTLESS
LEDGER
Distributed systems and cryptography are elements of the communication infrastructure. We need a third element: game theory.

Who controls the system? Nobody‚Ä¶ everybody!
11
PAST
FUTURE
DISTRIBUTED SYSTEMS
No absolute power, no single point of failure.


Don‚Äôt trust, verify!
12
Nobody can break the rules‚Ä¶
and
‚Ä¶everybody can verify.
CRYPTOGRAPHY


Align incentives: collective self-protecting system
13
GAME THEORY
Equilibrium in which attacking the system is less convenient than protecting it.

Cost of the attack: make malicious behaviours expensive.


14
ANALOG PROPERTIES
FOR DIGITAL THINGS
Consensus as ‚Äúlaw of Physics‚Äù for digital world

Who owns what? Let‚Äôs write it down!
15
A blockchain is a public ledger of transactional data.
World's first writing ‚Äî cuneiform ‚Äî traces its beginnings back to an ancient system of accounting.
WHO

OWNS

WHAT
Writing systems: from prehistory to history of humankind.

More copies are better than one!
16
Distributed and replicated across a system of multiple nodes in a network.
All ‚Äúledger keepers‚Äù should work together, using the same set rules, to verify the transactions to add to each copy of the finalized ledger. 


17
Atoms can‚Äôt be copy & pasted and are obliged to follow the arrow of time!
Bits can be copy & pasted and are not obliged to follow the arrow of time!
Entropy, irreversibility and the arrow of time
In a distributed system is hard to ensure that the information follows a consequential time. Also, the arrow of time could bypassed reverting transactions. The ledger of information must respect a precise history and must not allow arbitrary creation, duplication or deletion of information. 

A chain of transactions organized in blocks
18
The ‚Äúblock‚Äù refers to a set of transactions that are proposed and verified by the other nodes and eventually added to the ledger (no copy & paste).
The ‚Äúchain‚Äù refers to the fact that each block of transactions contains proof (a cryptographic hash) of what was in the previous block (arrow of time).





Can transactions be reverted or modified ex-post? No! Dura lex, sed lex!


A distributed state machine
19
A machine
The evolution of the states of the system is determined‚Ä¶

SYSTEM STATE
S0

SYSTEM STATE
Sn

SYSTEM STATE
S1
BLOCK N
SMART CONTRACT
TRANSACTION
The evolution of the states of the system is determined‚Ä¶
‚Ä¶acting on atoms, through the inviolable laws of Physics!
‚Ä¶acting on bits, through what?
BLOCK 1
SMART CONTRACT
TRANSACTION
The more complex the state transition the more power I consume: adding 1 transaction per month is easy, executing thousands of smart contracts on the AVM is complicated.

The responsibility of correct information
20
Margaret Hamilton in 1969, standing next to listings of the software she and her MIT team produced for the Apollo project.
BLOCK PROPOSER
GENESIS BLOCK
BLOCK 1
BLOCK N
BLOCK N+1
How should we replace the role played by the law of Physics in evolving the state of a machine?

With a set of software rules, called Consensus Protocol that evolves the state of the system. 
Paleo-computing: no IDE, no syntax highlighting, handwritten code (value of conciseness).

The architecture of consensus
21
Temple of Concordia
Valley of Temples (Agrigento), 440-430 B.C.
How to choose the proposer for the next block for a public and permissionless blockchain?

How to ensure that there is no ambiguity in the choice of the next block?

How to ensure that the blockchain stays unique and has no forks?

How to ensure that consensus mechanism itself can evolve over time while the blockchain is an immutable ledger?
It is the largest and best-preserved Doric temple in Sicily[5] and one of the best-preserved Greek temples in general,[1] especially of the Doric order. Named after Concordia.
In ancient Roman religion, Concordia is the goddess who embodies agreement in society. Her Greek equivalent is usually regarded as Harmonia, with musical harmony a metaphor for an ideal of social concord.
This tells us a lot about the value of such a civilization!

Proof of Work consensus mechanism
22
Miners compete with each other to append the next block and earn a reward for the effort, fighting to win an expensive computational battle.
The more computational power, the higher the probability of being elected as block proposer.
PoW


Proof of Work limits
23
Huge electrical consumption

Concentration of governance in few mining farms

Soft-forking of the blockchain


Proof of Stake consensus mechanism
24
Network participants show their commitment and interest in keeping the ledger safe and secure proving the ownership of value stored on the ledger itself.

The higher the skin in the game the higher the probability of being elected as block proposer.


Proof of Stake limits
25
CRITICAL ISSUES
BONDED PROOF OF STAKE
Validators bind their stake, to show their commitment in validating and appending a new block. Misbehaviors are punished.
Participating in the consensus protocol makes users‚Äô stakes illiquid
Risk of economic barrier to entry
DELEGATED PROOF OF STAKE
Users delegate the validation of new blocks to a fixed committee, through weighted voting based on their stakes.
Known delegate nodes, therefore exposed to DDoS attacks
Centralization of governance
BPoS
DPoS
It‚Äôs like playing Battleship knowing the coordinates of adversary in advance.

Is the Blockchain Trilemma unsolvable?
26
TRILEMMA
2
3
1
SECURITY
SCALABILITY
DECENTRALIZATION


27
ALGORAND CONSENSUSPure Proof of Stake (PPoS)

Scalable		6000 TPS, billions of users
Fast			< 3.9 s per block
Secure		0 downtime for over 23M blocks
Low fees		0.001 ALGO per txn
No Soft Forks 	prob. < 10-18
Instant Transaction Finality
Carbon neutral
Minimal hardware node requirements
No delegation or binding of the stake
No minimum stake
Secure with respect DDoS
Network Partitioning resilience
Algorand PPoS Consensus
28
Silvio Micali  Algorand Founder
Professor MIT, Turing Award, G√∂del Prize
Digital Signatures, Probabilistic Encryption, Zero-Knowledge Proofs,
Verifiable Random Functions and other primitives of modern cryptography.

Flat fee is very powerful for business models: given a users base, an estimation of users activity (tx/day) a business team can foresee the costs and hedge the on-chain resources.

Tamper-proof, unique and verifiable dices
29





VRF
Dices are perfectly balanced and equiprobable, nobody could tamper their result!
Keep observing dice rolls by no means increases the chance of guessing the next result!
Each dice is uniquely signed by its owner, nobody can roll someone else dices!
Dices are publicly verifiable, everybody can read the results of a roll!


Who chose the next block?
30
VRF
VRF
VRF
VRF
WIN!
Each ALGO could be assimilated to a tamper-proof dice participating in a safe and secret cryptographic dice roll. More ALGOs more dices to roll.

For each new block, dice rolls are performed in a distributed, parallel and secret and manner, directly on online accounts‚Äô hardware (in microseconds).

The winner is revealed in a safe and verifiable way only after winning the dice roll, proposing the next block.


A glimpse on ‚Äúsimplified‚Äù VRF sortition
31
A secret key (SK) / public verification key (VK) pair is associated with each ALGO in the account
For each new round r of the consensus protocol a threshold L(r) is defined
Each ALGO in the account performs a VRF, using its own secret key (SK), to generate:
a pseudo-random number:		Y = VRFSK(seed)
the verifiable associated proof:	‚ç¥SK(seed)
If Y = VRFSK(seed) < L(r), that specific ALGO ‚Äúwins the lottery‚Äù and viraly propagates the proof of its victory ‚ç¥SK(seed) to other network‚Äôs nodes, through ‚Äúgossiping‚Äù mechanism
Others node can use the public verification key (VK) to verify, through ‚ç¥SK(seed), that the number Y was generated by that specific ALGO, owned by the winner of the lottery


Pure Proof of Stake, in short
32
Through the cryptographic lottery, an online account is elected with probability directly proportional to its stake: each ALGO corresponds to an attempt to win the lottery!




An account is elected to propose the next block
A committee is elected to filter and vote on the block proposals
A new committee is elected to reach a quorum and certify the block
The new block is appended to the blockchain
Each round of the consensus protocol appends a new block in the blockchain:


Ok, but‚Ä¶ how long does it take?
33


Less than 3.9 seconds!
34


Pure Proof of Stake security
35
Algorand‚Äôs decentralized Byzantine consensus protocol can tolerate an arbitrary number of malicious users as long as honest users hold a super majority of the total stake in the system.
The adversary does not know which users he should corrupt.
The adversary realizes which users are selected too late to benefit from attacking them. 
Each new set of users will be privately and individually elected.
During a network partition in Algorand, the adversary is never able to convince two honest users to accept two different blocks for the same round.
Algorand is able to recover shortly after network partition is resolved and guarantees that new blocks will be generated at the same speed as before the partition.


Pure Proof of Stake: the output pre-upgrade!
36
BLOCKS
> 23M with 0 downtime
BLOCKCHAIN SIZE
~ 1 TB
ADDRESSES
> 27M with ~ 2M monthly active addresses
AVG. BLOCK FINALIZATION
~ 3.8 sec per block
TXNS WEEKLY VOLUME
~ 11M transactions (March 2022)
TPS WEEKLY PEAK
~ 6000 transactions per second
* up to August 2022
This is the output that such a complex machine has produced so far‚Ä¶ We still have to answer to the opening question: ‚Äúis this machine good at consuming input resources to produce the desired output for which it has been designed for?‚Äù

Algorand Layer-1 primitives
37

Algorand Standard Assets (ASA)

Atomic Transfers
(AT)

Algorand Virtual Machine (AVM)





Algorand State Proof (ASP)




TRUSTLESS
INTEROPERABLE
POST-QUANTUM SECURE





What does execution on Layer-1 mean?
38
B1
B2
...
Br
ASC1 CALL
ASC1 CALL
ASC1 CALL
TXN 1
ASC1 CALL
L-1 CONSENSUS COMMITTEE

3.8 sec
L-1 CONSENSUS COMMITTEE

3.8 sec
L-1 CONSENSUS COMMITTEE

3.8 sec
EXECUTION ON PPoS CONSENSUS LEVEL
up to 25000 txn/block
up to 25000 txn/block
AVM execution does not slow down the whole blocks production!
up to 25000 txn/block
up to 25000 txn/block
Each complex system is characterised by a ‚Äúnatural pulsation‚Äù. For electrical networks is the grid‚Äôs frequency, for automated assembly lines is the production tack-time. We, humans, are complex systems, our natural pulsations is the heartbeat. Block time is Algorand‚Äôs heartbeat!

What does execution on Layer-1 mean?
39
Smart Contracts are executed ‚Äúat consensus level‚Äù
Benefit from network's speed, security, and scalability
Fast trustless execution (~3.8 seconds per block)
Low cost execution (0.001 ALGO regardless SC‚Äôs complexity)
Instant Finality of Smart Contracts‚Äô effects
Native interoperability with Layer-1 primitives
Safe high level languages (PyTeal, Reach, Clarity)
Low energy consumption


40
ALGORAND SUSTAINABILITY‚ÄúPermission-less‚Äù is not ‚ÄúResponsibility-less‚Äù
Full paper: ‚ÄúProof of Stake Blockchain Efficiency Framework‚Äù

‚ÄúPermission-less‚Äù is not ‚ÄúResponsibility-less‚Äù
41
Algorand is a permission-less network üï∏, so no centralized authority can know or impose how node runners should power their nodes üíª.
As decentralized infrastructure, Algorand is responsible for its impact on Planet Earth üåè, although no centralized authority controls it.
Algorand should acts proactively (not hiding behind the ‚Äúpermission-less excuse‚Äù) and set blockchains‚Äô sustainability bar high üå±.


Proof of unsustainable Work
42
Proof of Work is a planetary wasteful computational battle, in which miners MUST burn energy to secure the blockchain.
Showing off personal commitment in the ecosystem through the consumption of computational and energetic resources is at the core of PoW consensus mechanism.

Our planet Earth can no longer afford unsustainable technologies.


43
A matter of orders of magnitude (PoW vs PPoS)
Eiffel Tower
Paper sheet thickness
2x Burj Khalifa
103
102
10-5
Full paper: ‚ÄúProof of Stake Blockchain Efficiency Framework‚Äù


44
You like to win easy!
What about others Proof of Stake?


When the going gets tough, the tough get going (PoS vs PPoS)
45
Blockchain sustainability must consider scalable end-user transactions (uTPS) finality (f), nodes hardware (N), and secure network decentralization (d).





Being sustainable while centralized, insecure or not scalable
is worthless!
DECENTRALIZED
SECURE
NETWORK
(running on Consensus Protocol)

(f, N, d)
INPUT
OUTPUT
POWER
(Pval)
END-USER
FINALIZED
TRANSACTIONS
(uTPS)


Reframing the question
46
Is Algorand blockchain efficient
at consuming energy 
to finalize end user useful transactions
in a secure, scalable and decentralized way?


Algorand solves blockchain trilemma sustainably
47
Algorand transactions are 100% available to end-users
(other PoS blockchains consume their own transactions for consensus)
Algorand transactions are 100% instantly final
(other PoS must consume the energy of several blocks to ensure transactions‚Äô finality)
Algorand transactions are secured by a very decentralized network
(some PoS blockchain have only few validators)
Algorand security is a feature of its own efficiency
(Algorand never experienced downtime since the genesis block)
Full paper: ‚ÄúProof of Stake Blockchain Efficiency Framework‚Äù


48
ALGORAND NETWORKSNodes, Indexer and APIs

Algorand Node configurations
49
Non-Relay Nodes
Participate in the PPoS consensus (if hosting participation keys)
Connect only to Relay Nodes 
Light Configuration: store just the lastest 1000 blocks (Fast Catch-Up)
Archival Configuration: store all the chain since the genesis block

Relay Nodes
Communication routing to a set of connected Non-Relay Nodes
Connect both with Non-Relay Nodes and Relay Nodes
Route blocks to all connected Non-Relay Nodes
Highly efficient communication paths, reducing communication hops


Example of Algorand Network topology
50
Node Metrics
Non-Relay Nodes: 	> 1600
Relay Nodes:		> 120


51
Access to Algorand Network
The Algorand blockchain is a distributed system of nodes each maintaining their local state based on validating the history of blocks and the transactions therein. Blockchain state integrity is maintained by the consensus protocol which is implemented within the Algod daemon (often referred to as the node software).

An application connects to the Algorand blockchain through an Algod client, requiring:

a valid Algod REST API endpoint IP address
an Algod token from an Algorand node connected to the network you plan to interact with

These two pieces of information can be provided by your local node or by a third party node aaS.


52
How to get an Algod Client?
There are three ways to get a REST API Algod endpoint IP address / access token, each with their respective pros and cons depending on development goals.


53
Algorand Networks


54
Algorand Node -  Writing on the blockchain
Install (Linux, MacOS, Windows)
Choose a network (MainNet, TestNet, BetaNet, PrivateNet)
Start & Sync with the network, Fast Catchup

genesis.json (mainnet)

{
  "alloc": [
    {
      "addr": "7377777777777777...77777777UFEJ2CI",
      "comment": "RewardsPool",
      "state": {
        "algo": 10000000000000,
        "onl": 2
      }
    },
    {
      "addr": "Y76M3MSY6DKBRHBL7C3...F2QWNPL226CA",
      "comment": "FeeSink",
      "state": {
        "algo": 1000000,
        "onl": 2
      }
    },
    ...
  ],
  "fees": "Y76M3MSY6DKBRHBL7C3NNDX...F2QWNPL226CA",
  "id": "v1.0",
  "network": "mainnet",
  "proto": "https://github.com/algorandfoundation/specs/tree/5615adc36bad610c7f165fa2967f4ecfa75125f0",
  "rwd": "737777777777777777777...77777777UFEJ2CI",
  "timestamp": 1560211200
}
Interacting with Algorand Nodes
CLI utilities: 		goal, kmd and algokey
REST API interface: 	algod V2, kmd, indexer
Algorand SDKs: 		JavaScript, Python, Java o Go


55
Algorand Indexer - Reading from the blockchain
The Indexer provides a REST API interface of API calls to query the Algorand blockchain. The Indexer REST APIs retrieves blockchain data from a PostgreSQL database, populated using the Indexer instance connected to an Archival Algorand node that reads blocks‚Äô data. As with the Nodes, the Indexer can be used as a third-party service.


56
How to interact with Algorand Node and Indexer


57
Algorand Community SDKs
Java
JavaScript
Python
Go
C#
Rust
Dart
PHP
Algorand SDKs
Swift


58
Algorand Developer Portal


59
Awesome Algorand


60
Algorand Wallets
Pera Wallet + Wallet Connect
MyAlgo Wallet
AlgoSigner


61
Algorand Explorers
Dappflow


62
ALGORAND INTEROPERABILITYState Proofs and Post-Quantum Security
Credits to Noah Grossman for contents

Trustless interoperability
63
Algorand approach to interoperability:
cross-chain transactions should rely just on
Trust in departing consensus protocol
Trust in arrival consensus protocol
without centralized bridges or validator networks, to handle the assets.

Algorand State Proofs remove trusted centralized operators becoming the first trustless post-quantum secure L1 interoperability standard.


Post-Quantum Secure Algorand State Proofs
64
Post-Quantum secure and immutable proofs, attesting blockchain state, generated by Pure Proof of Stake consensus protocol.


65
ALGORAND TRANSACTIONS
Core element of blocks

Changing blockchain state
66
Transactions are the core element of blocks, which define the evolution of distributed ledger state. There are six transaction types in the Algorand Protocol:
Payment
Key Registration
Asset Configuration
Asset Freeze
Asset Transfer
Application Call

These six transaction types can be specified in particular ways that result in more granular perceived transaction types.


Signature, fees and round validity
67
In order to be approved, Algorand‚Äôs transactions must comply with:

Signatures: transactions must be correctly signed by its sender, either a Single Signature, a Multi Signature or a Smart Signature / Smart Contract
Fees: in Algorand transactions fees are a way to protect the network from DDoS. In Algorand Pure PoS fees are not meant to pay ‚Äúvalidation‚Äù (as it happens in PoW blockchains). In Algorand you can delegate fees.
Round validity: to handle transactions‚Äô idempotency, letting Non-Archival nodes participate in Algorand Consensus, transactions have an intrinsic validity of 1000 blocks (at most). 


Browse through a transaction
68
Transactions are characterized by two kind of fields (codec):

common (header)
specific (type)


Payment Transaction example
69
Here is a transaction that sends 5 ALGO from one account to another on MainNet.


70
ALGORAND ACCOUNTS
Transactions‚Äô Authorization

Signatures
71
SECRET KEY
32 bytes
PUBLIC KEY
32 bytes
Ed25519
GENERATOR
Algorand uses Ed25519 high-speed, high-security elliptic-curve signatures.
ALGORAND ADDRESS
58 characters
MNEMONIC PHRASE
25 words
RANDOM SEED
ADDRESS: the public key is transformed into an Algorand Address, by adding a 4-byte checksum to the end of the public key and then encoding it in base32.

MNEMONIC: the 25-word mnemonic is generated by converting the private key bytes into 11-bit integers and then mapping those integers to the bip-0039 English word list.


Algorand Accounts
72
Accounts are entities on the Algorand blockchain associated with specific on-chain local sate. An Algorand Address is the unique identifier for an Algorand Account.
All the potential keys pairs ‚Äúalready exists‚Äù mathematically, we just keep discovering them.


Transactions Authorization and Rekey-To
73
PUBLIC ADDRESS
MULTI SIGNATURE ACCOUNT
LOCAL STATE
SECRET KEY [1/N]
PUBLIC ADDRESS
STANDARD ACCOUNT
LOCAL STATE
SECRET KEY
CONTRACT ACCOUNT
SECRET KEY [k/N]
SECRET KEY [N/N]
Algorand Rekeying: powerful Layer-1 protocol feature which enables an Algorand account to maintain a static public address while dynamically rotating the authoritative private spending key(s). Any Account can Rekey either to a Standard Account, MultiSig Account or LogicSig Contract Account.
PUBLIC ADDRESS
SMART SIG
LOCAL STATE


Account State Minimum Balance
74


75
ASAAlgorand Standard Assets on Layer-1

ARC-3
Algorand Standard Asset Parameters Conventions for Fungible and Non-Fungible Tokens

76
Status: Final
Defines Fungible Tokens, Pure NFT, Fractional NFTs
Very comprehensive definition of NFT‚Äôs metadata (e.g. images, videos, audio tracks, etc.) and traits as JSON structure
Binding between the ASA and the JSON structure uploaded on external storage (e.g. IPFS, Arweave, etc.)
Circulating tokens: ~ 42,000
Generators: https://arc3.xyz/, https://app.algodesk.io/
Example: https://www.nftexplorer.app/asset/429087615



ARC-69
Community Algorand Standard Asset Parameters Conventions for Digital Media Tokens

77
Status: Living
Adopted both in art and games (https://algoseas.io/)
Simple and succinct definition of NFT‚Äôs metadata and traits as JSON structure. Allows tratits configuration after minting
Binding between the ASA and the JSON structure uploaded directly on-chain as transaction notefield
Circulating tokens: ~ 565,000 (most popular standard)
Generators: https://app.algodesk.io/
Example:  https://www.nftexplorer.app/asset/420625533



ARC-19
Templating of NFT ASA URLs for mutability

78
Status: Final
Has been adopted as building block of non-fungible-domain standard proposed by NFDomains
Makes use of ASA Reserve Address to update the NFT metadata binding over time.
Circulating tokens: ~ 26,000
Generators: https://app.nf.domains/
Example: https://app.nf.domains/name/john.algo



ARC-20 / ARC-18
Smart ASA / Royalty Enforcement Specification

79
Status: ARC-18 (Draft), ARC-20 (Draft)
Binds a native ASA with a Smart Contract creating a ‚ÄúSmart ASA‚Äù, useful whenever a decentralized transferability policy must be enforced on-chain (e.g. royalties, vesting, limited amount per day, etc.)
Allows ASA programmable full reconfigurability on the AVM (e.g. enforcing a rule to upgrade a trait of a NFT character in game, etc.) 
ARC-20 Reference Implementation
ARC-18 Reference Implementation (using Beaker)



80
Algorand Virtual Machine
Programming on Algorand






Cosimo Bassi
Solutions Architect at Algorand

cosimo.bassi@algorand.com


What‚Äôs a Smart Contract ?
82
Smart Contracts are deterministic programs through which complex decentralized trustless applications can be executed on the AVM.
The Algorand Virtual Machine is a Turing-complete secure execution environment that runs on Algorand consensus layer.
What‚Äôs the AVM ?


Algorand Virtual Machine purpose: approving or rejecting transactions‚Äô effects on the blockchain according to Smart Contracts‚Äô logic.
What the AVM actually does?
83
AVM approves transactions‚Äô effects if and only if:
There is a single non-zero value on top of AVM‚Äôs stack;
AVM rejects transactions‚Äô effects if and only if:
There is a single zero value on top of AVM‚Äôs stack;
There are multiple values on the AVM‚Äôs stack;
There is no value on the AVM‚Äôs stack;


How the AVM works?
84
Suppose we want the AVM to check the following assertion:
1 + 2 = 3
[...]
[...]
[...]
[...]
[...]
STACK MACHINE


How the AVM works?
85
Suppose we want the AVM to check the following assertion:
1 + 2 = 3
1
[...]
[...]
[...]
[...]
STACK MACHINE
pushing first operand


How the AVM works?
86
Suppose we want the AVM to check the following assertion:
1 + 2 = 3
2
1
[...]
[...]
[...]
STACK MACHINE
pushing
second operand


How the AVM works?
87
Suppose we want the AVM to check the following assertion:
1 + 2 = 3
2
1
[...]
[...]
[...]
STACK MACHINE
applying
operator


How the AVM works?
88
Suppose we want the AVM to check the following assertion:
1 + 2 = 3
3
[...]
[...]
[...]
[...]
STACK MACHINE


How the AVM works?
89
Suppose we want the AVM to check the following assertion:
1 + 2 = 3
3
3
[...]
[...]
[...]
STACK MACHINE
pushing
last operand


How the AVM works?
90
Suppose we want the AVM to check the following assertion:
1 + 2 = 3
3
3
[...]
[...]
[...]
STACK MACHINE
applying
operator


How the AVM works?
91
Suppose we want the AVM to check the following assertion:
1 + 2 = 3
true
[...]
[...]
[...]
[...]
STACK MACHINE


AVM architecture
92
Sender
Receiver
Fee
FirstValid
LastValid
Amount
Lease
Note
TypeEnum
‚Ä¶ 
[0]:    Bytes
[i]:    Bytes
[255]:  Bytes
TRANSACTION
TRANSACTION ARGS
[0]:  UInt64 / Bytes
[i]:  UInt64 / Bytes
[63]: UInt64 / Bytes
APP GLOBAL K/V PAIRS
[0]:  UInt64 / Bytes
[i]:  UInt64 / Bytes
[15]: UInt64 / Bytes
APP LOCAL K/V PAIRS
[0]:  UInt64/ Bytes
[i]:  UInt64/ Bytes
[15]: UInt64/ Bytes
[0]:  Bytes
[i]:  Bytes
[3]:  Bytes
[0]:  UInt64
[i]:  UInt64
[7]:  UInt64
APP IDs ARRAY
ACCOUNT ARRAY
APP ARG ARRAY
txn TypeEnum
int 1
==
txn Receiver
addr AOC7...
==
&&
txn Fee
int 1000
<=
&&
arg 0
byte base64 "YmlhbmNvbmlnbGlv"
==
&&
txn Amount
int 42
==
txn Amount
int 77
==
||
&&
PROGRAM
[0]:    UInt64 / Bytes
[i]:    UInt64 / Bytes
[999]:  UInt64 / Bytes
STACK MACHINE
[0]:    UInt64 / Bytes
[i]:    UInt64 / Bytes
[255]:  UInt64 / Bytes
SCRATCH SPACE
[0]:  UInt64
[i]:  UInt64
[7]:  UInt64
ASSET ARRAY
Stateless properties
Stateful properties
Processing
Max Key + Value size: 128 bytes
Block Number
Block Timestamp
...
BLOCK GLOBAL VARS
ALGO / ASA Balance
...
ACCOUNT STATE VARS


NODE
COMPILERS
IDEs
How to program the AVM?
93
Algorand Virtual Machine (AVM)
TEAL
AVM Bytecode
PyTeal
TEAL
AVM Bytecode
Reach Lang
TEAL
AVM Bytecode
TEAL
AVM Bytecode
Languages...
...
...
...


94
ASC1Algorand Smart Contracts on Layer-1

AVM Modes
95
ASC1
Mode 1:
SMART SIGNATURE
(Stateless)
Mode 2:
SMART CONTRACTS
(Stateful)


Mode 1:
SMART SIGNATURE
(Stateless)
Stateless ASC1
96
ASC1
Mode 2:
APPLICATION
(Stateful)
Contract
Account
Application
Smart Signatures are programs whose logic governs transactions‚Äô authorization.
Domain: transient properties
‚ÄúStateless ASC1 deal with assets‚Äô spending approvals‚Äù
Delegated
Signature


Stateful ASC1
97
ASC1
Mode 1:
LOGIC SIGNATURE
(Stateless)
Contract
Account
Application
Delegated
Signature
Smart Contracts are programs whose logic reads and writes blockchain‚Äôs state, creates and submits transactions.
Domain: persistent properties
‚ÄúStateful ASC1 deal with accounts‚Äô state changes‚Äù
Mode 2:
SMART CONTRACTS
(Stateful)


98
SMART SIGNATURESAuthorizing transactions through TEAL logic

Creating Smart Signature
99
txn TypeEnum
int 1
==
txn Receiver
addr AOC7...
==
&&
txn Fee
int 1000
<=
&&
arg 0
byte base64 "YmlhbmNvbmlnbGlv"
==
&&
txn Amount
int 42
==
txn Amount
int 77
==
||
&&
PROGRAM
NODE
SMART SIGNATURE
CONTRACT PUBLIC ADDRESS
Compiled TEAL Max Size: 1000 bytes
OpCode Max Budget: 20.000


Contract Account
100
CONTRACT ACCOUNT

ASC1 PUBLIC ADDRESS
LOCAL STATE
STANDARD / MULTISIG
ACCOUNT
TRANSACTION
SMART SIGNATURE
STANDARD / MULTISIG
ACCOUNT
funds...
appends...
binding


Delegated Signature
101
STANDARD / MULTISIG
ACCOUNT
SMART SIGNATURE
DELEGATED SIGNATURE
TRANSACTION
STANDARD / MULTISIG
ACCOUNT
STANDARD / MULTISIG
ACCOUNT
signs...
appends...
PUBLIC ADDRESS
SECRET KEY
binding


102
SMART CONTRACTSDecentralized Applications on Algorand

Deploying Applications on chain
103
txn TypeEnum
int 1
==
txn Receiver
addr AOC7...
==
&&
txn Fee
int 1000
<=
&&
submits...
APPROVAL PROGRAM
NODE
APPLICATION CALL
TRANSACTION
CREATE
B1
B2
B3
...
Br
BLOCKCHAIN
APPLICATION ID
Compiled TEAL Max Size: 2048 bytes (+3 Extra Pages)
OpCode Max Budget: 700 (x16 Atomic Calls)
arg 0
byte base64 "YmlhbmNvbmlnbGlv"
==
&&
CLEAR PROGRAM
The Approval Program is responsible for processing all application calls to the contract, with the exception of the Clear Call. This program is responsible for implementing most of the logic of an Application.
The Clear Program is used to handle accounts using the Clear Call to remove the smart contract from their balance record.
State Schema
The State Schema specifies the memory allocation of the application.


Application Minimum Balance requirements
104


Calling Applications
105
APPLICATION ID
GLOBAL STATE
uint64
bytes
APPLICATION CALL
TRANSACTION
NO-OP
APP USER ACCOUNT
Generic application calls to execute the Approval Program
APPROVAL PROGRAM
CLEAR PROGRAM
LOCAL STATE
uint64
bytes
APPLICATION CALL
TRANSACTION
OPTIN
Application call used by Accounts to participate in an Application enabling Local State usage.
APPLICATION CALL
TRANSACTION
UPDATE
APPLICATION CALL
TRANSACTION
DELETE
APPLICATION CALL
TRANSACTION
CLOSE-OUT
Application call used by Accounts to close out their participation in an Application. This call can fail based on the TEAL logic, preventing the account from removing the Local State.
APPLICATION CALL
TRANSACTION
CLEAR
Application call used by Accounts to close out their participation in an Application. This call will always remove the account‚Äôs Local State whether the program succeeds or fails.
Application call to update the application‚Äôs Programs
(if enabled)
Application call to delete the application
(if enabled)
APP ACCOUNT


Interacting with Applications
106
APPLICATION CALL
TRANSACTION
APPLICATION
(PROGRAM ON-CHAIN)
APP USER
ACCOUNT
EXTERNAL LOCAL STATE
APP USER
ACCOUNT 1
LOCAL STATE

KYC:    PENDING
APP USER
ACCOUNT 2
LOCAL STATE

KYC:    REJECTED
GLOBAL STATE

INTEREST RATE:    1%
INNER
TRANSACTION
Apps
Arguments
Assets
Accounts
LOG VALUE
EXTERNAL GLOBAL STATE

INTEREST RATE:    2%
Up to 256 Inner Transactions
per App Call
read / write
read / write
read only
read only
Application Call Arrays define the state context of the execution
With Inner Txns App can
transfer ALGOs,
interact with ASAs (create, opt-in, transfer, etc‚Ä¶),
interact with other Apps
(create, opt-in, call, etc‚Ä¶)
GROUP TRANSACTION

SCRATCH SPACE
read only
write


Contract 2 Contract interaction
107
APPLICATION

1
APPLICATION

2
APPLICATION

i
APPLICATION

7
APPLICATION

8
An application may not call itself, even indirectly. This is referred to as re-entrancy and is explicitly forbidden. 
An application may only call into other applications up to a stack depth of 8.
Inner App Call
Inner App Call
Inner App Call
Inner App Call


An application may issue up to 256 inner transactions to increase its budget (max budget of 179.2k!), but the max call budget is shared for all applications in the group.
Smart Contract Execution: op-code budget
The op-code budget is consumed during execution of every Algorand Smart Contract according to the op-code cost. In order for the evaluation to succeed, the budget must not exceed 700 points. Each App Call (also as Inner Transactions) provides an additional budget of 700 points to the whole execution.
108
BUDGET COSTLY
APPLICATION
KNOWN BUDGET TOP-UP APPLICATION
Inner
App Call
DISPOSABLE BUDGET TOP-UP APPLICATION
Inner
App Create/Delete


Smart Contract Interface: ABI
109
The ABI (Application Binary Interface) defines the encoding/decoding of data types and a standard for exposing and invoking methods in a Smart Contract. The specification is defined in ARC-4.
At a high level, the ABI allows contracts to define an API so clients know exactly what the Smart Contract is expecting to be passed (like a ‚ÄúSmart Contract Swagger‚Äù).


110
TEALAVM assembly-like language

Smart Signature Example
111
Suppose we want to develop a Smart Signature that approves a transaction if and only if:

is ‚ÄúPayment‚Äù type transaction;
the receiver is a specific ‚ÄúADDR‚Äù;
fees are less or equal to ‚Äú1000 microALGO‚Äù;
first argument is equal to ‚Äúbianconiglio‚Äù;
amount is  equal to ‚Äú42 ALGO‚Äù;
or amount is equal to ‚Äú77 ALGO‚Äù;

Where do we start?


Smart Signature as ‚ÄúTransaction Observer‚Äù
112
Smart Signatures can be defined as a ‚Äútransactions‚Äô observers‚Äù: programs that meticulously check all fields in the transaction (or in a group of transactions) that intend to ‚Äúapprove‚Äù or ‚Äúreject‚Äù based on TEAL logic.

To translate those 6 semantically defined example‚Äôs conditions into TEAL we need to check which transaction fields are going to be controlled by Smart Signature‚Äôs logic.



Let's start with the translation...


Translating conditions into TEAL‚Ä¶
113
is ‚ÄúPayment‚Äù type transaction;
txn TypeEnum
int 1
==
1


114
the receiver is a specific ‚ÄúADDR‚Äù;
txn Receiver
addr AOC7...
==
2
Translating conditions into TEAL‚Ä¶


115
fees are less or equal to ‚Äú1000 microALGO‚Äù;
txn Fee
int 1000
<=
3
Translating conditions into TEAL‚Ä¶


116
first argument is equal to ‚Äúbianconiglio‚Äù;
arg 0
byte base64 "YmlhbmNvbmlnbGlv"
==
4
Translating conditions into TEAL‚Ä¶


117
amount is  equal to ‚Äú42 ALGO‚Äù;
txn Amount
int 42000000
==
5
Translating conditions into TEAL‚Ä¶


118
amount is  equal to ‚Äú77 ALGO‚Äù;
txn Amount
int 77000000
==
6
Translating conditions into TEAL‚Ä¶


119
Logic connectors‚Ä¶
txn TypeEnum
int 1
==
txn Receiver
addr AOC7...
==
&&
txn Fee
int 1000
<=
arg 0
byte base64 "YmlhbmNvbmlnbGlv"
==
&&
&&
txn Amount
int 42000000
==
txn Amount
int 77000000
==
||
&&
[...]
[...]
STACK
[...]
[...]
[...]
1
2
3
4
5
6


120
Logic connectors‚Ä¶
txn TypeEnum
int 1
==
txn Receiver
addr AOC7...
==
&&
txn Fee
int 1000
<=
arg 0
byte base64 "YmlhbmNvbmlnbGlv"
==
&&
&&
txn Amount
int 42000000
==
txn Amount
int 77000000
==
||
&&
[...]
[...]
STACK
[...]
[...]
[...]
1
2
3
4
5
6
This is probably the most complex phase in TEAL programming, because you need to keep in mind the state of the stack.

This phase is drastically simplified with the use of PyTEAL, Python binding for TEAL, which automatically performs this concatenation, saving us the effort of thinking about the state of the stack.


121
Execution‚Ä¶
txn TypeEnum
int 1
==
txn Receiver
addr AOC7...
==
&&
txn Fee
int 1000
<=
arg 0
byte base64 "YmlhbmNvbmlnbGlv"
==
&&
&&
txn Amount
int 42000000
==
txn Amount
int 77000000
==
||
&&
1
STACK
[...]
[...]
[...]
[...]


122
Execution‚Ä¶
txn TypeEnum
int 1
==
txn Receiver
addr AOC7...
==
&&
txn Fee
int 1000
<=
arg 0
byte base64 "YmlhbmNvbmlnbGlv"
==
&&
&&
txn Amount
int 42000000
==
txn Amount
int 77000000
==
||
&&
1
1
STACK
[...]
[...]
[...]


123
Execution‚Ä¶
txn TypeEnum
int 1
==
txn Receiver
addr AOC7...
==
&&
txn Fee
int 1000
<=
arg 0
byte base64 "YmlhbmNvbmlnbGlv"
==
&&
&&
txn Amount
int 42000000
==
txn Amount
int 77000000
==
||
&&
1
1
[...]
[...]
[...]
STACK


124
Execution‚Ä¶
txn TypeEnum
int 1
==
txn Receiver
addr AOC7...
==
&&
txn Fee
int 1000
<=
arg 0
byte base64 "YmlhbmNvbmlnbGlv"
==
&&
&&
txn Amount
int 42000000
==
txn Amount
int 77000000
==
||
&&
1
STACK
[...]
[...]
[...]
[...]


125
Execution‚Ä¶
txn TypeEnum
int 1
==
txn Receiver
addr AOC7...
==
&&
txn Fee
int 1000
<=
arg 0
byte base64 "YmlhbmNvbmlnbGlv"
==
&&
&&
txn Amount
int 42000000
==
txn Amount
int 77000000
==
||
&&
[...]
[...]
STACK
1
[...]
AOC7...


126
Execution‚Ä¶
txn TypeEnum
int 1
==
txn Receiver
addr AOC7...
==
&&
txn Fee
int 1000
<=
arg 0
byte base64 "YmlhbmNvbmlnbGlv"
==
&&
&&
txn Amount
int 42000000
==
txn Amount
int 77000000
==
||
&&
[...]
[...]
STACK
1
AOC7...
AOC7...


127
Execution‚Ä¶
txn TypeEnum
int 1
==
txn Receiver
addr AOC7...
==
&&
txn Fee
int 1000
<=
arg 0
byte base64 "YmlhbmNvbmlnbGlv"
==
&&
&&
txn Amount
int 42000000
==
txn Amount
int 77000000
==
||
&&
[...]
[...]
1
AOC7...
AOC7...
STACK


128
Execution‚Ä¶
txn TypeEnum
int 1
==
txn Receiver
addr AOC7...
==
&&
txn Fee
int 1000
<=
arg 0
byte base64 "YmlhbmNvbmlnbGlv"
==
&&
&&
txn Amount
int 42000000
==
txn Amount
int 77000000
==
||
&&
1
STACK
1
[...]
[...]
[...]


129
Execution‚Ä¶
txn TypeEnum
int 1
==
txn Receiver
addr AOC7...
==
&&
txn Fee
int 1000
<=
arg 0
byte base64 "YmlhbmNvbmlnbGlv"
==
&&
&&
txn Amount
int 42000000
==
txn Amount
int 77000000
==
||
&&
1
STACK
1
[...]
[...]
[...]


130
Execution‚Ä¶
txn TypeEnum
int 1
==
txn Receiver
addr AOC7...
==
&&
txn Fee
int 1000
<=
arg 0
byte base64 "YmlhbmNvbmlnbGlv"
==
&&
&&
txn Amount
int 42000000
==
txn Amount
int 77000000
==
||
&&
1
STACK
[...]
[...]
[...]
[...]


131
Execution‚Ä¶
txn TypeEnum
int 1
==
txn Receiver
addr AOC7...
==
&&
txn Fee
int 1000
<=
arg 0
byte base64 "YmlhbmNvbmlnbGlv"
==
&&
&&
txn Amount
int 42000000
==
txn Amount
int 77000000
==
||
&&
[...]
[...]
STACK
1
[...]
1000


132
Execution‚Ä¶
txn TypeEnum
int 1
==
txn Receiver
addr AOC7...
==
&&
txn Fee
int 1000
<=
arg 0
byte base64 "YmlhbmNvbmlnbGlv"
==
&&
&&
txn Amount
int 42000000
==
txn Amount
int 77000000
==
||
&&
[...]
[...]
STACK
1
1000
1000


133
Execution‚Ä¶
txn TypeEnum
int 1
==
txn Receiver
addr AOC7...
==
&&
txn Fee
int 1000
<=
arg 0
byte base64 "YmlhbmNvbmlnbGlv"
==
&&
&&
txn Amount
int 42000000
==
txn Amount
int 77000000
==
||
&&
[...]
[...]
STACK
1
1000
1000


134
Execution‚Ä¶
txn TypeEnum
int 1
==
txn Receiver
addr AOC7...
==
&&
txn Fee
int 1000
<=
arg 0
byte base64 "YmlhbmNvbmlnbGlv"
==
&&
&&
txn Amount
int 42000000
==
txn Amount
int 77000000
==
||
&&
1
STACK
1
[...]
[...]
[...]


135
Execution‚Ä¶
txn TypeEnum
int 1
==
txn Receiver
addr AOC7...
==
&&
txn Fee
int 1000
<=
arg 0
byte base64 "YmlhbmNvbmlnbGlv"
==
&&
&&
txn Amount
int 42000000
==
txn Amount
int 77000000
==
||
&&
[...]
[...]
STACK
1
1
bianconiglio


136
Execution‚Ä¶
txn TypeEnum
int 1
==
txn Receiver
addr AOC7...
==
&&
txn Fee
int 1000
<=
arg 0
byte base64 "YmlhbmNvbmlnbGlv"
==
&&
&&
txn Amount
int 42000000
==
txn Amount
int 77000000
==
||
&&
1
[...]
STACK
1
bianconiglio
bianconiglio


137
Execution‚Ä¶
txn TypeEnum
int 1
==
txn Receiver
addr AOC7...
==
&&
txn Fee
int 1000
<=
arg 0
byte base64 "YmlhbmNvbmlnbGlv"
==
&&
&&
txn Amount
int 42000000
==
txn Amount
int 77000000
==
||
&&
1
[...]
STACK
1
bianconiglio
bianconiglio


138
Execution‚Ä¶
txn TypeEnum
int 1
==
txn Receiver
addr AOC7...
==
&&
txn Fee
int 1000
<=
arg 0
byte base64 "YmlhbmNvbmlnbGlv"
==
&&
&&
txn Amount
int 42000000
==
txn Amount
int 77000000
==
||
&&
1
STACK
1
[...]
[...]
1


139
Execution‚Ä¶
txn TypeEnum
int 1
==
txn Receiver
addr AOC7...
==
&&
txn Fee
int 1000
<=
arg 0
byte base64 "YmlhbmNvbmlnbGlv"
==
&&
&&
txn Amount
int 42000000
==
txn Amount
int 77000000
==
||
&&
1
STACK
1
[...]
[...]
1


140
Execution‚Ä¶
txn TypeEnum
int 1
==
txn Receiver
addr AOC7...
==
&&
txn Fee
int 1000
<=
arg 0
byte base64 "YmlhbmNvbmlnbGlv"
==
&&
&&
txn Amount
int 42000000
==
txn Amount
int 77000000
==
||
&&
1
STACK
1
[...]
[...]
[...]


141
Execution‚Ä¶
txn TypeEnum
int 1
==
txn Receiver
addr AOC7...
==
&&
txn Fee
int 1000
<=
arg 0
byte base64 "YmlhbmNvbmlnbGlv"
==
&&
&&
txn Amount
int 42000000
==
txn Amount
int 77000000
==
||
&&
1
STACK
1
[...]
[...]
[...]


142
Execution‚Ä¶
txn TypeEnum
int 1
==
txn Receiver
addr AOC7...
==
&&
txn Fee
int 1000
<=
arg 0
byte base64 "YmlhbmNvbmlnbGlv"
==
&&
&&
txn Amount
int 42000000
==
txn Amount
int 77000000
==
||
&&
1
STACK
[...]
[...]
[...]
[...]


143
Execution‚Ä¶
txn TypeEnum
int 1
==
txn Receiver
addr AOC7...
==
&&
txn Fee
int 1000
<=
arg 0
byte base64 "YmlhbmNvbmlnbGlv"
==
&&
&&
txn Amount
int 42000000
==
txn Amount
int 77000000
==
||
&&
42000000
STACK
1
[...]
[...]
[...]


144
Execution‚Ä¶
txn TypeEnum
int 1
==
txn Receiver
addr AOC7...
==
&&
txn Fee
int 1000
<=
arg 0
byte base64 "YmlhbmNvbmlnbGlv"
==
&&
&&
txn Amount
int 42000000
==
txn Amount
int 77000000
==
||
&&
42000000
42000000
STACK
[...]
[...]
1


145
Execution‚Ä¶
txn TypeEnum
int 1
==
txn Receiver
addr AOC7...
==
&&
txn Fee
int 1000
<=
arg 0
byte base64 "YmlhbmNvbmlnbGlv"
==
&&
&&
txn Amount
int 42000000
==
txn Amount
int 77000000
==
||
&&
42000000
42000000
[...]
[...]
1
STACK


146
Execution‚Ä¶
txn TypeEnum
int 1
==
txn Receiver
addr AOC7...
==
&&
txn Fee
int 1000
<=
arg 0
byte base64 "YmlhbmNvbmlnbGlv"
==
&&
&&
txn Amount
int 42000000
==
txn Amount
int 77000000
==
||
&&
1
STACK
1
[...]
[...]
[...]


147
Execution‚Ä¶
txn TypeEnum
int 1
==
txn Receiver
addr AOC7...
==
&&
txn Fee
int 1000
<=
arg 0
byte base64 "YmlhbmNvbmlnbGlv"
==
&&
&&
txn Amount
int 42000000
==
txn Amount
int 77000000
==
||
&&
42000000
STACK
1
[...]
1
[...]


148
Execution‚Ä¶
txn TypeEnum
int 1
==
txn Receiver
addr AOC7...
==
&&
txn Fee
int 1000
<=
arg 0
byte base64 "YmlhbmNvbmlnbGlv"
==
&&
&&
txn Amount
int 42000000
==
txn Amount
int 77000000
==
||
&&
42000000
77000000
STACK
1
[...]
1


149
Execution‚Ä¶
[...]
1
1
42000000
77000000
txn TypeEnum
int 1
==
txn Receiver
addr AOC7...
==
&&
txn Fee
int 1000
<=
arg 0
byte base64 "YmlhbmNvbmlnbGlv"
==
&&
&&
txn Amount
int 42000000
==
txn Amount
int 77000000
==
||
&&
STACK


150
Execution‚Ä¶
0
txn TypeEnum
int 1
==
txn Receiver
addr AOC7...
==
&&
txn Fee
int 1000
<=
arg 0
byte base64 "YmlhbmNvbmlnbGlv"
==
&&
&&
txn Amount
int 42000000
==
txn Amount
int 77000000
==
||
&&
STACK
1
[...]
[...]
1


151
Execution‚Ä¶
0
txn TypeEnum
int 1
==
txn Receiver
addr AOC7...
==
&&
txn Fee
int 1000
<=
arg 0
byte base64 "YmlhbmNvbmlnbGlv"
==
&&
&&
txn Amount
int 42000000
==
txn Amount
int 77000000
==
||
&&
STACK
1
[...]
[...]
1


152
Execution‚Ä¶
1
txn TypeEnum
int 1
==
txn Receiver
addr AOC7...
==
&&
txn Fee
int 1000
<=
arg 0
byte base64 "YmlhbmNvbmlnbGlv"
==
&&
&&
txn Amount
int 42000000
==
txn Amount
int 77000000
==
||
&&
STACK
1
[...]
[...]
[...]


153
Execution‚Ä¶
1
txn TypeEnum
int 1
==
txn Receiver
addr AOC7...
==
&&
txn Fee
int 1000
<=
arg 0
byte base64 "YmlhbmNvbmlnbGlv"
==
&&
&&
txn Amount
int 42000000
==
txn Amount
int 77000000
==
||
&&
STACK
1
[...]
[...]
[...]


154
Execution‚Ä¶
1
txn TypeEnum
int 1
==
txn Receiver
addr AOC7...
==
&&
txn Fee
int 1000
<=
arg 0
byte base64 "YmlhbmNvbmlnbGlv"
==
&&
&&
txn Amount
int 42000000
==
txn Amount
int 77000000
==
||
&&
STACK
[...]
[...]
[...]
[...]


155
Conclusion‚Ä¶
1
txn TypeEnum
int 1
==
txn Receiver
addr AOC7...
==
&&
txn Fee
int 1000
<=
arg 0
byte base64 "YmlhbmNvbmlnbGlv"
==
&&
&&
txn Amount
int 42000000
==
txn Amount
int 77000000
==
||
&&
STACK
[...]
[...]
[...]
[...]
True


156
Smart Signature written in PyTEAL


157
PyTEAL
Writing Smart Contracts with Python



Jason Paulos
Senior Software Engineer at Algorand



Matteo Almanza
Blockchain Engineer at Algorand



What‚Äôs PyTEAL?
159
PyTEAL is a Python language binding for Algorand Virtual Machine.
PyTEAL allows Smart Contracts and Smart Signatures to be written in Python and then compiled to TEAL.


160
It‚Äôs easier with PyTEAL!
TEAL Source Code
txn Receiver
addr AOC7...
==
txn Amount
int 1000
<=
&&
COMPILE...
AVM bytecode
PyTEAL Source Code
And(
Txn.Receiver == Addr(AOC7...),
    	Txn.Amount <= Int(1000),
)

TEAL Source Code
txn Receiver
addr AOC7...
==
txn Amount
int 1000
<=
&&
COMPILE...
COMPILE...
AVM bytecode


PyTEAL Basics - Intro
161
You‚Äôre writing Python code that produces TEAL code.
from pyteal import *

program = ... # a pyteal expression
teal_source = compileTeal(program, mode=Mode.Application, version=7)

>>> teal_source
"#pragma version 7\nintcblock 0 1\ntxn NumAppArgs\nintc_0 // 0\n==\nbnz main_l4\ntxna ApplicationArgs 0\npushbytes 0x90e75c9d..."



PyTEAL Basics - Intro
162
PyTEAL expressions represent an abstract syntax tree (AST)
# [...]
program = Seq(
   For(
  i.store(Int(0)),
  i.load() < Int(16),
  i.store(i.load() + Int(1)))
   .Do(
       App.globalPut(
Concat(Bytes("index"), Itob(i.load())),
Int(1))
   ),
   Approve(),
)
Seq
For
Approve
store
<
store
Do
‚Ä¶


PyTEAL Basics - Types (1/2)
163
Two basic types:
uint64
byte strings
i = Int(5)

x = Bytes("content")
y = Bytes(b"\x01\x02\x03")
z = Bytes("base16", "05")
Boolean? Logic ops on uints: 0 false, non zero true

PyTEAL Basics - Types (2/2)
164
Conversion between types
Itob - integer to bytes (8-byte big endian)
Btoi - bytes to integer
Itob(i) # produces the byte string 0x0000000000000005
Btoi(z) # produces the integer 5


PyTEAL Basics - Math operators
165
Math and logic operators (uint as boolean: 0 is false, non zero is true)
i = Int(10)
j = i * Int(2) + Int(1) # => Add(Mul(i, Int(2)), Int(1))
k = And(Int(1), Or(Int(1), Int(0)))
	
	
	# Expressions are not optimized
	z = j * j # => Mul(Add(Mul(i, Int(2)), Int(1)), Add(Mul(i, Int(2)), Int(1)))
Everything is an expression, and stay so

PyTEAL Basics - Byte string manipulation
166
Byte string manipulation
x = Bytes("content")
y = Concat(Bytes("example "), x) # "example content"
z = Substring(y, Int(2), Len(y)) # "ample content"


PyTEAL Basics - Crypto utilities
167
Built-in crypto utilities
h_sha256 = Sha256(z)
h_sha512_256 = Sha512_256(z)
h_keccak = Keccak256(z)


PyTEAL Basics - Fields (1/3)
168
Fields from the current transaction
Txn.sender()
Txn.accounts.length()
Txn.application_args.length()
Txn.accounts[1]
Txn.application_args[0]
Txn.group_index()


PyTEAL Basics - Fields (2/3)
169
Fields from transactions in the current atomic group
Gtxn[0].sender()
Gtxn[Txn.group_index() - Int(1)].sender()
Gtxn[Txn.group_index() - Int(1)].accounts[2]

# Gtxn (and other globals) indexes can be both (python) int and expr

Some objects can be accessed both with immediates and stack based expr (different opcodes beneath)

PyTEAL Basics - Fields (3/3)
170
Fields from execution context
Global.group_size()
Global.round() # current round number
Global.latest_timestamp() # UNIX timestamp of last round


PyTEAL Basics - Logs
171
Log publicly viewable messages to the chain
	Log(Bytes("message"))



PyTEAL Basics - State (1/2)
172
Global - one instance per application
App.globalPut(Bytes("status"), Bytes("active")) # write to global key "status"

status = App.globalGet(Bytes("status")) # read global key "status"

App.globalDel(Bytes("status")) # delete global key "status"

# Can also access global state of other smart contracts ‚Äì no secrets


PyTEAL Basics - State (1.5/2)
173
Global - one instance per application
# Remember that we are building expressions, not fetching values

old_status = App.globalGet(Bytes("status")) # read global key "status"
program = Seq(
	# Update status
App.globalPut(Bytes("status"), Bytes("frozen")), # write to global key "status"
# Check if was previously active
If(old_status != Bytes("frozen")).Then(
Log(Bytes("Was active")) # <= Will never execute 
)
)



PyTEAL Basics - State (2/2)
174
Local - one instance per opted-in account per application
App.localPut(Txn.sender(), Bytes("level"), Int(1)) # write to sender's local key "level"
App.localPut(Txn.accounts[1], Bytes("level"), Int(2))  # write to other account's local key "level"

sender_level = App.localGet(Txn.sender(), Bytes("level"))  # read from sender's local key "level"

App.localDel(Txn.sender(), Bytes("level"))  # delete sender's local key "level"


PyTEAL Basics - Control Flow (1/5)
175
Approve the transaction and immediately exit
Approve()
Reject the transaction and immediately exit
Reject()


PyTEAL Basics - Control Flow (2/5)
176
Multiple expressions can be joined into a sequence
program = Seq(
   App.globalPut(Bytes("count"), App.globalGet(Bytes("count")) + Int(1)),
   Approve()
)


PyTEAL Basics - Control Flow (3/5)
177
Basic conditions can be expressed with If, Then, Else, ElseIf
program = Seq(
   If(App.globalGet(Bytes("count")) == Int(100))
   .Then(
       App.globalPut(Bytes("100th caller"), Txn.sender())
   )
   .Else(
       App.globalPut(Bytes("not 100th caller"), Txn.sender())
   ),
   App.globalPut(Bytes("count"), App.globalGet(Bytes("count")) + Int(1)),
   Approve(),
)


PyTEAL Basics - Control Flow (4/5)
178
Larger conditions can be expressed with Cond
program = Cond(
   [Txn.application_id() == Int(0), on_create],
   [Txn.on_completion() == OnComplete.UpdateApplication, on_update],
   [Txn.on_completion() == OnComplete.DeleteApplication, on_delete],
   [Txn.on_completion() == OnComplete.OptIn, on_opt_in],
   [Txn.on_completion() == OnComplete.CloseOut, on_close_out],
   [Txn.on_completion() == OnComplete.NoOp, on_noop],
   # error if no conditions are met
)


PyTEAL Basics - Control Flow (5/5)
179
Loops can be expressed with For and While
i = ScratchVar(TealType.uint64)

on_create = Seq(
   For(i.store(Int(0)), i.load() < Int(16), i.store(i.load() + Int(1)))
   .Do(
       App.globalPut(Concat(Bytes("index"), Itob(i.load())), Int(1))
   ),
   Approve(),
)


PyTEAL Basics - Subroutines (1/2)
180
Sections of code can be put into subroutines (Python decorators)
@Subroutine(TealType.uint64)
def isEven(i):
   return i % Int(2) == Int(0)

App.globalPut(Bytes("value_is_even"), isEven(Int(10)))


PyTEAL Basics - Subroutines (2/2)
181
Recursion is allowed
@Subroutine(TealType.uint64)
def recursiveIsEven(i):
   return (
       If(i == Int(0))
       .Then(Int(1))
       .ElseIf(i == Int(1))
       .Then(Int(0))
       .Else(recursiveIsEven(i - Int(2)))
   )


PyTEAL Basics - Inner Transactions (1/3)
182
Every application has control of an account
Global.current_application_address()


PyTEAL Basics - Inner Transactions (2/3)
183
Applications can send transactions from this account ‚Äì even to other Apps
Limitation: no reentrancy
Seq(
   InnerTxnBuilder.Begin(),
   InnerTxnBuilder.SetFields(
       {
           TxnField.type_enum: TxnType.Payment,
           TxnField.receiver: Txn.sender(),
           TxnField.amount: Int(1_000_000),
       }
   ),
   InnerTxnBuilder.Submit() # send 1 Algo from the app account to the transaction sender
)


PyTEAL Basics - Inner Transactions (3/3)
184
appAddr = Global.current_application_address()
Seq(
   InnerTxnBuilder.Begin(),
   InnerTxnBuilder.SetFields(
       {
           TxnField.type_enum: TxnType.AssetConfig,
           TxnField.config_asset_name: Bytes("PyTEAL Coin"),
           TxnField.config_asset_unit_name: Bytes("PyTEAL"),
           TxnField.config_asset_url: Bytes("https://pyteal.readthedocs.io/"),
           TxnField.config_asset_decimals: Int(6),
           TxnField.config_asset_total: Int(800_000_000),
           TxnField.config_asset_manager: appAddr,
       }
   ),
   InnerTxnBuilder.Submit(), # create a PyTEAL Coin asset
   App.globalPut(Bytes("PyTealCoinId"), InnerTxn.created_asset_id()) # remember the asset ID
)


PyTEAL Basics - Other operations
185
See docs at https://pyteal.readthedocs.io/en/stable/overview.html

Wide math
Balances, assets holding and parameters
JSON (limited) parsing
‚Ä¶



A pythonic Algorand stack
186
Algorand Python SDK
PyTEAL & Beaker
PyTest for Smart Contracts unit-tests and e2e-tests
TEAL Debugger
Algorand Sandbox Docker in dev mode
PyCharm IDE & AlgoDEA plug-in


‚ÄúZero to Hero PyTEAL‚Äù crash course
187
Join and learn in 12 lessons!


188
Algorand ABI
Writing ABI Compliant Smart Contracts with PyTEAL





Stefano De Angelis
Research Solutions Architect at Algorand

stefano@algorand.com


What is an ABI?
190
An ABI (Application Binary Interface) is an interface between two binary program modules, one of which is at the level of machine code. The interface defines the convention of how data is encoded/decoded into/out of the machine code via computational routines.


Algorand ABI is the interface that defines a standard on how to call Algorand Smart Contracts, the encoding/decoding of Application Call arguments and the return values.

ARC4 is the specification for Algorand ABI. It defines a standard approach to call smart contract methods and describes the ABI interface description object. It is a human readable and machine readable JSON file showing the methods of a smart contracts, the required input parameters and the return values.
Algorand ABI
191
ARC: Algorand Request for Comments is a collection of specifications (collected by the algorand Foundation) that talk about standardisation of development approaches. The community discuss on ARC and eventually reach an agreement making the ARC standardised.Example: I write a smart contract with a method that takes a string as a parameter. That parameter must be somehow encoded in TEAL before calling the method. So for an external client, I need to instruct them on how to call my smart contract method properly, and how to encode parameter.

Why an Algorand ABI?
Smart Contract developers can publish the interface JSON file before deploying the application on the blockchain.
Client applications just need to read the interface JSON file and properly call the smart contract methods and process return values.
‚Äî--------------
Algorand Blockchain
‚Äî--------------
Smart Contract A
Smart Contract B
ABI Interface Repository
{    ‚Ä¶}
ABI Interface JSON A
ABI Interface JSON B
{    ‚Ä¶}
dApp1
dApp2
Wallet
Read
Invoke method
192
The Algorand ABI facilitates the interaction between client applications and smart contracts. 

ABI Interface JSON File (1/3)
The ABI Interface JSON file is composed by three distinct JSON types called Method, Interface and Contract.

A Method description defines a method with the expected arguments and return type.
193

ABI Interface JSON File (2/3)
An Interface description defines a collection of Methods. It is a way to represent the set of methods required to implement an ARC4 compliant Smart Contract. It can be extended with other methods.
194

ABI Interface JSON File (3/3)
A Contract description defines a specific Smart Contract that currently exists on the blockchain, and specifies all the methods the contract implements. It is an implementation of an Interface.
195

ARC4 ABI Methods standard
The ARC4 defines a method signature as a way to identify a smart contract method. It is expressed as method name, arguments types, return type.
add(uint64, uint64)uint128

The method selector is the first 4 bytes of the hash of a signature
SHA-512/256 hash (in hex): 8aa3b61f0f1965c3a1cbf‚Ä¶70184ff89dc114e877b1753254a
Method selector (in hex): 8aa3b61f

The method selector to be specified as the first argument of an Application Call transaction. The smart contract must route to the corresponding method matching the selector.
196
Method signatures could be very long as well as their hashed value. To optimise the space and comply with the limit of 128 bytes per arg, ARC4 introduced method selectors.

PyTEAL ABI - Intro
PyTEAL can now support the implementation of ARC4 ABI Standardised applications by introducing the following new features:

Encoding/decoding basic types;
Encoding/decoding reference types;
Encoding/decoding transaction types;
ABI methods standard;
ABI Interface JSON File.
197

PyTEAL ABI - Basic Types
AVM stack types limited to uint64, bytes. PyTEAL ABI supports new basic types whose encoding is standardized to AVM basic types.
PyTeal Type
Description
abi.UintN
An N-bit unsigned integer, where 8 <= N <= 64
abi.Bool
A boolean value that can be either 0 or 1
abi.Byte
An 8-bit unsigned integer used to indicate non-numeric data
abi.StaticArray[T,N]
A fixed-length array of T with N elements
abi.Address
A 32-byte Algorand address. This is an alias for abi.StaticArray[abi.Byte, Literal[32]]
abi.StaticBytes[N]
A fixed-length array with N elements of abi.Byte
abi.DynamicArray[T]
A variable-length array of T
abi.DynamicBytes
A variable length array of abi.Byte
abi.String
A variable-length byte array assuming UTF-8 content. This is an alias for abi.DynamicArray[abi.Byte]
abi.TupleN, abi.NamedTuple
A tuple of multiple types, where 0 <= N <= 5
198

PyTEAL ABI - Setting Values
To create and instantiate an ABI Type we have the abi.make() method. 
All Basic Types have a set() method which can be used to assign a value. 
my_address = abi.make(abi.Address)
my_bool = abi.make(abi.Bool)
my_uint64 = abi.make(abi.Uint64)
my_tuple = abi.make(abi.Tuple3[abi.Address, abi.Bool, abi.Uint64]

program = Seq(
   my_address.set(Txn.sender()),
   my_bool.set(Txn.fee() == Int(0)),
   my_uint64.set(5000),
   my_tuple.set(my_address, my_bool, my_uint64)
)
199

PyTEAL ABI - Getting Values
Basic types have a get() method which can be used to extract that value. 
	my_address.get() # Returns the 32-byte Algorand address of Txn.sender()
200

PyTEAL ABI - Working with NamedTuples
A NamedTuple is a PyTEAL Tuple that has named elements.
class User(abi.NamedTuple):
   address: abi.Field[abi.Address]
   balance: abi.Field[abi.Uint64]

my_user = User()

program = Seq(
   my_user.set(Txn.sender(), 5000),
   Approve(),
)
201

PyTEAL ABI - Reference Types
Blockchain entities passed to the AVM within the foreign arrays of the method call.
PyTeal Type
Description
abi.Account
Represents an account stored in the Txn.accounts array
abi.Asset
Represents an asset stored in the Txn.assets array
abi.Application
Represents an application stored in the Txn.applications array
202

PyTEAL ABI - Working with Reference Types (1/2)
Reference types expose methods to obtain the ID of the object referenced and to access that object‚Äôs parameters
@Subroutine(TealType.none)
def check_ref_values(my_user: abi.Account, my_asset: abi.Asset, my_app: abi.Application):
   return Assert(
   	my_user.address() == my_app.params().creator_address(),
   	my_asset.asset_id() == Int(5),
   )

203

PyTEAL ABI - Working with Reference Types (2/2)
Asset holding properties can be accessed using reference types
@Subroutine(TealType.none)
def ensure_asset_balance_is_nonzero(my_user: abi.Account, my_asset: abi.Asset):
   return Assert(
my_user.asset_holding(my_asset).balance() > Int(0)),
   )

204

PyTEAL ABI - Transaction Types
Transaction objects which are part of the same group of a method call. 
A method may have multiple Transaction Type arguments, in which case they must appear in the same order as the method‚Äôs arguments immediately before the method call.
PyTeal Type
Description
abi.Transaction
A catch-all for any transaction type
abi.PaymentTransaction
A payment transaction
abi.KeyRegisterTransaction
A key registration transaction
abi.AssetConfigTransaction
An asset configuration transaction
abi.AssetTransferTransaction
An asset transfer transaction
abi.AssetFreezeTransaction
An asset freeze transaction
abi.ApplicationCallTransaction
An application call transaction
205

PyTEAL ABI - Working with Transaction Types (1/2)
Get the absolute group index of a specific transaction in the group
@Subroutine(TealType.none)
def handle_txn_args(
   any_txn: abi.Transaction, 
   pay: abi.PaymentTransaction,
   axfer: abi.AssetTransferTransaction):
   return Assert(
       any_txn.index() == Txn.group_index() - Int(3),
       pay.index() == Txn.group_index() - Int(2),
       axfer.index() == Txn.group_index() - Int(1),
   )

206

PyTEAL ABI - Working with Transaction Types (2/2)
Transaction Types expose a get() method which can be used to access fields from a transaction in the group
@Subroutine(TealType.none)
def check_txn(pay: abi.PaymentTransaction, sender: abi.Account):
   return Assert(
       pay.get().sender() == sender().address(),
       pay.get().receiver() == Global.current_application_address(),
   )

207

PyTEAL ABI - Subroutines
Subroutines can now return ABI values using the ABIReturnSubroutine decorator. The output keyword is now used to store the return value
@ABIReturnSubroutine
def get_account_balance(account: abi.Account, *, output: abi.Uint64) -> Expr:
   return Seq(
      (balance := abi.Uint64()).set(App.localGet(account.get(), Bytes("balance")),
      output.set(balance),      
   )

208

PyTEAL ABI - ARC4 Program
ABI Programs respond to two specific subtypes of application call transactions:
Method calls: which encode a specific method to be called and the method arguments
Bare app calls: which have no arguments and no return values

ARC4 Program
Router
Bare Calls
Methods
Subroutines
BARE CALL
TRANSACTION
Application call without arguments or return value. This is suited for on completion actions such as optin, close out, update, ..
METHOD CALL
TRANSACTION
[args]
Application call to a method of the smart contract. This call may pass arguments to a method and produce a return value. The first argument of this call is the method selector.
encode/decode/log
BARE CALL
TRANSACTION
App Create
Application creation app call. It can invoke an on completion action like optin, close out, update, ..
209

PyTEAL ABI - Registering Bare Calls
A bare app call handler can be registered with the router. The actions of a bare call handler can be either an Expr or a Subroutine 
CallConfig options indicates whether the action is able to be called during an app creation, a non-creation, or either
router = Router(
   name = "ExampleApp",
   bare_calls = BareCallActions(
      no_op = OnCompleteAction(action=Approve(), call_config=CallConfig.CREATE),
      opt_in = OnCompleteAction(action=Approve(), call_config=CallConfig.CREATE),
      close_out = OnCompleteAction(action=Approve(), call_config=CallConfig.CALL),
      update_application = OnCompleteAction(
                           action=Assert(Txn.sender() == Global.creator_address()), 
                           call_config=CallConfig.CREATE),
      delete_application = OnCompleteAction(action=Reject(), call_config=CallConfig.CALL),
   )
)
210

PyTEAL ABI - Registering Methods
A method decorator placed on top of the method subroutine can be used to register that method with the application router
CallConfig options can be specified within the decorator directly

  
@router.method(no_op=CallConfig.CALL, opt_in=CallConfig.CALL)
def my_method(a: abi.Uint64, b: abi.Uint64):
   return Seq(
      ...
   )
211

Nice, we finally know how to implement ARC4 programs! Uhm?
212

PyTEAL ABI - Compiling ARC4 Programs
The PyTEAL router object provides the compile_program() method to compile an ARC4 program into TEAL code.
This method generates the approval and clear state programs, along with an auto-generated Contract object which represents the contract interface! 
router = ...

approval_program, clear_state_program, contract = router.compile_program(
   version=6, optimize=OptimizeOptions(scratch_slots=True))

with.open("example.json", "w") as f:
   f.write(json.dumps(contract.dictify(), indent=4))
213

Pump my JSON: docstrings!
214

Pump my JSON: docstrings!
215

PyTEAL ABI - Calling an ARC4 Program (1/2)
ARC4 programs can be called of-chain with the SDKs





We can also use the goal CLI
Atomic Transaction Composer is an SDK utility to construct transactions,  transaction groups, and ABI method calls with the functions addTransaction() and addMethodCall()
Bare calls can be invoked with either goal app create or goal app <action> commands, where actions are optin, closeout, clear, update, or delete.
Method calls can be triggered via the goal app method command
216

ARC4 programs can be also called on-chain with a contrat-to-contract call
PyTEAL ABI - Calling an ARC4 Program (2/2)
Inner transactions can invoke other applications‚Äô ABI methods using the Inner Transaction Builder utility with the ExecuteMethodCall() function
InnerTxnBuilder.ExecuteMethodCall(
   app_id=56,
   method_signature="add(uint64,uint64)uint128",
   args=[5, 8],
)
217

AlgoBank Demo!
AlgoBank is your first ARC4 Program.

It acts as a escrow for users‚Äô funds. It exposes three ABI methods
deposit(): Deposit some funds in the AlgoBank;
getBalance(): Retrieve the user‚Äôs funds locked in;
withdraw(): Claim back funds from the deposit

Deployment environment:
Algorand Sandbox: Dockerized private network!
DappFlow: Algorand blockchain explorer
218

219
Beaker
Algorand dApp Has Never Been Easier





Chris Kim
Developer Advocate at Algorand

chris.kim@algorand.com


PyTeal, SDK may feel‚Ä¶
Unfamiliar
Complex
Overwhelming 


Note: share my experience. I found it difficult. It may feel this way. Going to show you how to do this easier 



Algorand dApp Architecture
show diagram of full dapp with frontend. compare with normal web app. 

today we will learn how to write and deploy your smart contract with Beaker and learn how to interact with it with Algorand Python SDK

Frontend
Web Server
Database
Web2 App Architecture
What normal web app looks like

TODO:

below frontend, put user icon 

Algorand SDK
Frontend
Web Server
Database
Algorand Dapp Architecture
Algorand
Smart contract
AVM
Smart contract
Algorand SDK
What Algorand dApp would look like
Some may not even need a database and web server. Direct interaction with Algorand blockchain. 

sdk go to web server 

signing transactions

TODO:

make the web2 parts stay the same as previous slide and just add in the new parts. 

add user and wallet (key icon) 

add toolbox icon for SDK 







key management 
let customer take care of it (wallets pera, myalgo, ..)
let server handle it. (need to encrypt)
or have custodial services like securitize



web server
serve all javascript to client

node server

Today we will learn

Introducing Beaker: The Way dApp
development should be
talk about PPoS, carbon negative, solved blockchain trilemma, built by Silvio Micali, a turing awards winner

Talk about AVM, why Algorand chose to create its own virtual machine. 

Python smart contract framework 

Code Organization (PyTeal)
Deploy/ Call (Algorand SDK)
Debugging
In short, it handles all the heavy lifting for you


Let‚Äôs see a direct comparison
https://github.com/algorand-devrel/beaker-calculator




Bare Pyteal

Smart contract code is unfamiliar
Need to manually define helper functions
Frontend setup is lengthy 

Beaker

Smart Contract organization is familiar
helper methods defined for you
Easier to deploy/call contract 
Comparison Recap
recap of the comparison 

Frontend
Web Server
Database
Algorand Dapp Architecture
Algorand
Algorand SDK
Smart contract
AVM
Smart contract
Algorand SDK
Smart contract
What Algorand dApp would look like
Some may not even need a database and web server. Direct interaction with Algorand blockchain. 

sdk go to web server 

signing transactions

TODO:
key management 
let customer take care of it (wallets pera, myalgo, ..)
let server handle it. (need to encrypt)
or have custodial services like securitize



web server
serve all javascript to client

node server

Today we will learn

Testing
Application Class
Application Client
Sandbox
State
Decorators
Smart Contract 
Deploy/Call
Beaker Components


Developer Environment Setup

Sandbox


Pyteal


Python Algorand SDK


Beaker

git clone https://github.com/algorand/sandbox.git
Packages to Install

Sandbox
Packages to Install
Beaker
Python SDK
PyTeal

Launch Sandbox / Git Clone



Create Virtual Environment



install All Required Packages 
Beaker Starter Kit
python3 venv venv
source ./venv/bin/activate
 
pip install -r requirements.txt
./sandbox up dev
git clone [beaker-starter-kit url]

Beaker: Smart Contract (PyTeal)

Testing
Application Client
Sandbox
Application Class
State
Handlers
Smart Contract 
Deploy/Call
Beaker Components

Application Class
State
Decorators
Smart Contract 

Testing
Application Client
Sandbox
Application Class
State
Handlers
Smart Contract 
Deploy/Call
Beaker Components

State
Decorators
Application Class
Smart Contract 

Application Class

Base class that all Beaker Applications should inherit from


Included logic 
Detect State Variables
OnComplete methods 
ABI Methods
internal subroutines
Abstraction = Simple Code

Testing
Application Client
Sandbox
Application Class
State
Handlers
Smart Contract 
Deploy/Call
Beaker Components

Application Class
Decorators
State
Smart Contract 

 Application(Global) State

Use Final typing construct that prevents re-assigning of the variable name as good practice

 Application(Global) State

Specify state characteristics here:
stack_type
key (optional)
default (optional)
static (optional)
descr (optional)
ABI json File

Specify state characteristics here:
stack_type
max_keys
key_gen (optional)
descr (optional)
 Application(Global) State

ABI json File

 Account(Local) State

Specify state characteristics here:
stack_type
key (optional)
default (optional)
static (optional)
descr (optional)

 Account(Local) State

Specify state characteristics here:
stack_type
max_keys
key_gen (optional)
descr (optional)

Testing
Application Client
Sandbox
Application Class
State
Handlers
Smart Contract 
Deploy/Call
Beaker Components

Application Class
State
Decorators
Smart Contract 

Decorators

@external

expose methods as ABI methods

automatically add the method to router
@internal

Used internally in the contract
Can access state variables

OnComplete externals

create
opt_in
delete
update
clear_state
close_out
Support Authorization to only allow certain accounts to execute the method

Decorators: @external

expose methods as ABI methods

automatically add the method to router

Decorators: @internal

returns Tealtype uint64

Not exposed to ABI

Decorators: @internal

Access internal methods like this

useful for repeated complex computation 

Decorators: OnComplete Externals

Available OnComplete Externals
create
opt_in
delete
update
clear_state
close_out

Decorators: Bare Externals

Only creator of the contract can call this method
Authorize accounts that hold certain tokens
Authorize account opted in

Smart Contract Recap


Application Class

Base class that Beaker Apps inherit from
Provide Basic functionalities
State

Application = Global
Account = Local
Exposed to ABI


Decorators

@external
@internal
OnComplete Externals
Authorization

Beaker: Deploy / Call Smart Contract
Don‚Äôt go too deep with ABI since Beaker does it automatically for you. 

Testing
Application Client
Sandbox
Application Class
State
Handlers
Smart Contract 
Deploy/Call
Beaker components

Application Client
Deploy/Call
Sandbox
Testing

Sandbox

Sandbox

Sandbox

Application Client

Application Client
Convenient way to interact with your smart contract 
Saving 750 lines of code!

Application Client


No more manually
creating transaction
signing transaction
submitting transaction
waiting for confirmation

Application client handles it for you



Recap


Sandbox

Easily set up testing with helper methods that:
create algod client 
get list of sandbox accounts
and more

Application Client


Provides over 20 helper methods you can leverage to easily deploy / call your smart contract



Complete 
RSVP App
Create Break points and run the code 

Create RSVP Event
Guest RSVP
Guest Check in
Guest Refund
Funds Withdrawal
Event Delete 
RSVP Features




Algorand dApp Architecture
What Beaker is
Complete RSVP Example
What Did We Learn Today?




Beaker is Amazing

Algodevs Resources
FOLLOW ME!

Thanks to the contributors!

Cosimo Bassi
Jason Paulos
Pietro Grassano
Matteo Almanza
Stefano De Angelis
Chris Kim
